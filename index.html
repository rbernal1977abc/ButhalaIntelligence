<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Bathala Intelligence ‚Äî v5.0</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
  <!-- Chart.js for Consensus Visualization -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <!-- PDF.js, Tesseract, Mammoth, SheetJS -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
  <script src="https://unpkg.com/tesseract.js@v2.1.0/dist/tesseract.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <!-- SQL.js for SQLite support -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.js"></script>
  <style>
    :root {
      --bg-0: #07090c;
      --bg-1: #0a0f17;
      --bg-2: #0d1420;
      --neon: #00ff88;
      --neon-2: #00cc6a;
      --neon-3: #00994d;
      --muted: #a0aec0;
      --error: #ff4444;
      --warn: #ffa500;
      --violet: #9b59b6;
      --card: #0a0f1a;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    html, body { height: 100%; font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu; }

    body {
      background:
        radial-gradient(1200px 600px at 20% -10%, rgba(0,255,136,.08), transparent 60%),
        radial-gradient(800px 500px at 120% 10%, rgba(155,89,182,.08), transparent 60%),
        linear-gradient(135deg, var(--bg-0), var(--bg-1), var(--bg-2));
      color: #fff;
      line-height: 1.5;
    }

    /* Layout */
    .app { display: flex; min-height: 100vh; }

    .sidebar {
      width: 300px;
      background: rgba(7,9,12,.8);
      backdrop-filter: blur(8px);
      border-right: 1px solid rgba(0,255,136,.35);
      padding: 18px;
      position: sticky;
      top: 0;
      align-self: flex-start;
      height: 100vh;
      overflow: auto;
    }

    .brand { display: flex; align-items: center; gap: 10px; margin-bottom: 18px; }

    .brand .logo {
      width: 36px;
      height: 36px;
      border-radius: 10px;
      background: radial-gradient(circle at 30% 30%, var(--neon), #0b2a1e 70%);
      box-shadow: 0 0 18px rgba(0,255,136,.5);
    }

    .brand h1 {
      font-size: 1.1rem;
      letter-spacing: .12em;
      font-weight: 900;
      background: linear-gradient(45deg, var(--neon), var(--neon-2), var(--neon-3));
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      text-transform: uppercase;
    }

    .menu-group { margin: 12px 0; }

    .menu-title {
      font-weight: 900;
      font-size: .8rem;
      letter-spacing: .1em;
      color: var(--muted);
      margin: 8px 4px;
    }

    .nav { display: flex; flex-direction: column; gap: 8px; margin-top: 6px; }

    .nav button {
      all: unset;
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 12px;
      border: 1px solid rgba(0,255,136,.35);
      border-radius: 10px;
      cursor: pointer;
      font-weight: 700;
      transition: all 0.2s ease;
    }

    .nav button:hover { background: rgba(0,255,136,.05); }

    .nav button.active {
      background: linear-gradient(135deg, rgba(0,255,136,.15), rgba(0,255,136,.05));
      box-shadow: 0 0 20px rgba(0,255,136,.15);
    }

    .nav .icon { width: 24px; text-align: center; }

    .history { margin-top: 14px; }

    .history h4 { margin: 6px 4px; color: var(--muted); font-size: .85rem; }

    .history-list { display: flex; flex-direction: column; gap: 6px; }

    .history-item {
      all: unset;
      cursor: pointer;
      display: flex;
      gap: 8px;
      align-items: flex-start;
      border: 1px solid rgba(255,255,255,.1);
      border-radius: 8px;
      padding: 8px;
      transition: border-color 0.2s ease;
    }

    .history-item:hover { border-color: rgba(0,255,136,.35); }

    .badge {
      font-size: .72rem;
      padding: 2px 6px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,.2);
      white-space: nowrap;
    }

    .content { flex: 1; max-width: 1400px; margin: 18px auto; padding: 18px; }

    .panel { display: none; }

    .panel.active { display: block; }

    /* Header card */
    .header-card {
      background: rgba(7,9,12,.98);
      border: 1px solid var(--neon);
      border-radius: 16px;
      padding: 20px;
      box-shadow: 0 0 40px rgba(0,255,136,.08);
    }

    .header-title {
      font-size: 1.9rem;
      font-weight: 900;
      margin: 0 0 6px;
      text-shadow: 0 0 12px rgba(0,255,136,.35);
    }

    .tagline { color: var(--muted); }

    /* Grid */
    .grid { display: grid; gap: 16px; grid-template-columns: repeat(12, 1fr); }

    .col-12 { grid-column: span 12; }

    .col-6 { grid-column: span 6; }

    .col-4 { grid-column: span 4; }

    .card {
      background: var(--card);
      border: 1px solid var(--neon);
      border-radius: 12px;
      padding: 16px;
    }

    /* Inputs */
    input, select, textarea {
      width: 100%;
      padding: 12px;
      border: 1px solid var(--neon);
      border-radius: 8px;
      background: rgba(0,0,0,.45);
      color: #fff;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    textarea {
      min-height: 80px;
      resize: vertical;
    }

    label {
      font-size: .8rem;
      color: var(--neon);
      margin-bottom: 6px;
      display: block;
    }

    /* Buttons */
    .btn {
      border: none;
      border-radius: 10px;
      padding: 12px 16px;
      font-weight: 800;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      transition: transform .15s ease, box-shadow .25s ease;
    }

    .btn:disabled { opacity: .6; cursor: not-allowed; }

    .btn-primary { background: linear-gradient(45deg, var(--neon), var(--neon-2)); color: #000; }

    .btn-danger { background: linear-gradient(45deg, #ff6b6b, #ff4444); color: #fff; }

    .btn-info { background: linear-gradient(45deg, #4facfe, #00f2fe); color: #000; }

    .btn-success { background: linear-gradient(45deg, #00cc6a, #00ff88); color: #000; }

    .btn-warning { background: linear-gradient(45deg, #ffa500, #ffb732); color: #000; }

    .btn-super { background: linear-gradient(45deg, #ff00ff, #ff0080); color: #fff; }

    .btn-forecast { background: linear-gradient(45deg, #00bfff, #0066ff); color: #fff; }

    .btn:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 10px 25px rgba(0,255,136,.25);
    }

    .status-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #ff4444;
    }

    .status-dot.connected {
      background: var(--neon);
      box-shadow: 0 0 0 0 rgba(0,255,136,.8);
      animation: pulse 1.5s infinite;
    }

    .status-dot.connecting {
      background: var(--warn);
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
      to { box-shadow: 0 0 0 14px rgba(0,255,136,0); }
    }

    /* Toasts */
    .toast-stack {
      position: fixed;
      right: 18px;
      bottom: 18px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 9999;
    }

    .toast {
      min-width: 260px;
      max-width: 360px;
      background: rgba(0,0,0,.85);
      border: 1px solid rgba(255,255,255,.12);
      backdrop-filter: blur(8px);
      color: #fff;
      padding: 12px 14px;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      display: flex;
      gap: 10px;
      align-items: flex-start;
    }

    .toast .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      flex-shrink: 0;
      margin-top: 4px;
    }

    .toast.success { border-color: rgba(0,255,136,.45); }

    .toast.error { border-color: rgba(255,68,68,.45); }

    .toast.warn { border-color: rgba(255,165,0,.45); }

    /* Loaders */
    .loading-wrap { display: none; align-items: center; gap: 10px; }

    .loading-wrap.active { display: flex; }

    .spinner3d {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      border: 3px solid rgba(0,255,136,.15);
      border-top-color: var(--neon);
      animation: spin 1s linear infinite;
      box-shadow: 0 0 20px rgba(0,255,136,.35) inset;
    }

    @keyframes spin { to { transform: rotate(360deg); } }

    /* Results */
    .response-grid { display: grid; gap: 16px; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); }

    .response-card {
      background: rgba(0,0,0,.3);
      border: 1px solid var(--neon);
      border-radius: 10px;
      padding: 16px;
    }

    .response-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      border-bottom: 1px solid rgba(0,255,136,.25);
      padding-bottom: 8px;
    }

    .actions { display: flex; gap: 8px; flex-wrap: wrap; }

    /* Consensus */
    .consensus-block {
      background: rgba(155,89,182,.10);
      border: 2px solid var(--violet);
      border-radius: 12px;
      padding: 16px;
      margin-top: 16px;
    }

    /* Database Connections */
    .database-connections {
      display: grid;
      gap: 16px;
      grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
      margin-bottom: 20px;
    }

    .db-connection-card {
      background: var(--card);
      border: 1px solid var(--neon);
      border-radius: 12px;
      padding: 16px;
      position: relative;
    }

    .db-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 1px solid rgba(0,255,136,.25);
    }

    .db-icon {
      font-size: 1.5rem;
      margin-right: 8px;
    }

    .db-status {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 0.8rem;
    }

    .connection-form {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .form-row {
      display: flex;
      gap: 10px;
    }

    .form-row > * {
      flex: 1;
    }

    .add-connection-btn {
      background: rgba(0,255,136,.1);
      border: 2px dashed var(--neon);
      color: var(--neon);
      padding: 20px;
      text-align: center;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .add-connection-btn:hover {
      background: rgba(0,255,136,.2);
      transform: translateY(-2px);
    }

    /* Database Type Badges */
    .db-type-badge {
      padding: 4px 8px;
      border-radius: 6px;
      font-size: 0.7rem;
      font-weight: 600;
      text-transform: uppercase;
    }

    .db-type-file { background: rgba(0,255,136,.2); border: 1px solid var(--neon); }
    .db-type-server { background: rgba(155,89,182,.2); border: 1px solid var(--violet); }
    .db-type-backend { background: rgba(255,165,0,.2); border: 1px solid var(--warn); }

    /* Footer */
    footer { margin: 24px 0 8px; text-align: center; color: var(--muted); }

    /* Responsive */
    @media (max-width: 1024px) {
      .sidebar { width: 90px; padding: 12px; }
      .brand h1 { display: none; }
      .menu-title { display: none; }
      .nav button span.label { display: none; }
    }

    @media (max-width: 640px) {
      .content { padding: 12px; }
      .col-6 { grid-column: span 12; }
      .col-4 { grid-column: span 12; }
      .btn { padding: 10px 12px; font-size: 0.9rem; }
      .database-connections { grid-template-columns: 1fr; }
      .form-row { flex-direction: column; }
    }
  </style>
</head>
<body>
<div class="app">
  <!-- Sidebar Navigation -->
  <aside class="sidebar">
    <div class="brand">
      <div class="logo"></div>
      <h1>Bathala Intelligence</h1>
    </div>

    <div class="menu-group">
      <div class="menu-title">MAIN</div>
      <div class="nav">
        <button data-panel="dashboard" class="active">
          <span class="icon">üè†</span>
          <span class="label">Dashboard</span>
        </button>
        <button data-panel="storage">
          <span class="icon">üìö</span>
          <span class="label">Database Storage</span>
        </button>
        <button data-panel="agents">
          <span class="icon">üîë</span>
          <span class="label">Agents Configuration</span>
        </button>
      </div>
    </div>

    <div class="menu-group history">
      <h4>Recent Searches</h4>
      <div id="searchHistory" class="history-list"></div>
      <h4 style="margin-top:10px">Recent Consensus</h4>
      <div id="consensusHistory" class="history-list"></div>
    </div>
  </aside>

  <main class="content">
    <!-- Header -->
    <section class="header-card">
      <div class="header-title">üõ°Ô∏è BATHALA INTELLIGENCE</div>
      <div class="tagline">An AI-Driven Governance Platform</div>
    </section>

    <!-- DASHBOARD: Search + Results + Consensus -->
    <section id="panel-dashboard" class="panel active">
      <div class="card">
        <h3>üîç INTELLIGENCE SEARCH</h3>
        <div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:10px">
          <input id="searchInput" placeholder="Enter your search query‚Ä¶" />
          <select id="aiProvider">
            <option value="compare">Compare All AI Agents</option>
            <option value="deepseek">AI Agent 1</option>
            <option value="openai">AI Agent 2</option>
            <option value="grok">AI Agent 3</option>
          </select>
          <select id="personaSelect" title="Agent Personality Mode">
            <option value="analyst">üßÆ Analyst</option>
            <option value="ethicist">üß≠ Ethicist</option>
            <option value="strategist" selected>üéØ Strategist</option>
            <option value="creative">üé® Creative</option>
          </select>
          <button class="btn btn-primary" id="searchBtn">üöÄ AI SEARCH</button>
          <button class="btn btn-info" id="localFileBtn">üìÅ FIND FILE</button>
          <button class="btn btn-info" id="localContentBtn">üîç FIND CONTENT</button>
          <button class="btn btn-info" id="combinedBtn">üîÑ BATHALA MODE</button>
          <button class="btn btn-warning" id="agentsBtn">ü§ñ BATHALA AGENTS</button>
          <!-- NEW: SUPER MODE BUTTON -->
          <button class="btn btn-super" id="superModeBtn">üåü SUPER MODE</button>
        </div>
      </div>

      <div class="card" id="resultsSection" style="display:none;margin-top:12px">
        <div class="response-header">
          <h3>üìä SEARCH RESULTS</h3>
          <div id="resultsInfo" style="color:var(--neon)">Ready for analysis</div>
        </div>
        <div id="resultsArea"></div>
        <div style="margin-top:12px">
          <button class="btn btn-primary" id="checkBalanceBtn" style="display:none">
            ‚öñÔ∏è CHECK & BALANCE
            <span style="margin-left:6px;background:linear-gradient(45deg,#9b59b6,#8e44ad);padding:2px 8px;border-radius:6px">Consensus Mode</span>
          </button>
          <!-- NEW: FORECAST BUTTON - FIXED SPELLING -->
          <button class="btn btn-forecast" id="forecastBtn" style="display:none">
            üìà FORECAST
            <span style="margin-left:6px;background:linear-gradient(45deg,#0066ff,#00bfff);padding:2px 8px;border-radius:6px">1-5 Year Projection</span>
          </button>
        </div>
      </div>

      <div class="card" style="margin-top:12px">
        <div class="response-header">
          <h3>‚öñÔ∏è Consensus Visualization</h3>
          <div>Radar Metrics</div>
        </div>
        <canvas id="consensusChart" height="260"></canvas>
        <div class="consensus-block" id="consensusBlock" style="margin-top:12px;display:none"></div>
      </div>
    </section>

    <!-- DATABASE STORAGE: Upload + Library + Database Connections -->
    <section id="panel-storage" class="panel">
      <div class="card col-12">
        <h3>üîó DATABASE CONNECTIONS</h3>
        
        <!-- Connection Guide -->
        <div style="background: rgba(255,165,0,.1); border: 1px solid var(--warn); border-radius: 8px; padding: 12px; margin-bottom: 16px;">
          <strong>üìã Connection Options:</strong>
          <div style="font-size: 0.8rem; margin-top: 8px;">
            ‚Ä¢ <strong>SQLite Files:</strong> Direct connection - perfect for NAS storage<br>
            ‚Ä¢ <strong>Excel Files:</strong> Direct connection for .xlsx and .xls files<br>
            ‚Ä¢ <strong>CSV Files:</strong> Direct connection for .csv files<br>
            ‚Ä¢ <strong>Server Databases:</strong> PostgreSQL, MySQL, Oracle, SQL Server<br>
            ‚Ä¢ <strong>Backend Required:</strong> Set up Bathala backend on your NAS<br>
            ‚Ä¢ <strong>Quick Start:</strong> Export server databases to SQLite format
          </div>
        </div>

        <div class="database-connections" id="databaseConnections">
          <!-- Database connection cards will be added here dynamically -->
        </div>

        <div class="add-connection-btn" id="addConnectionBtn">
          <div style="font-size: 2rem; margin-bottom: 8px;">‚ûï</div>
          <div>Add Database Connection</div>
          <div style="font-size: 0.8rem; color: var(--muted); margin-top: 4px;">
            SQLite ‚Ä¢ Excel ‚Ä¢ CSV ‚Ä¢ PostgreSQL ‚Ä¢ MySQL ‚Ä¢ Oracle ‚Ä¢ SQL Server
          </div>
        </div>
      </div>

      <div class="card col-12" style="border-style:dashed; margin-top: 20px;">
        <h3>üìö FILE DATABASE STORAGE</h3>
        <input type="file" id="fileInput" accept=".pdf,.docx,.txt,.jpg,.png,.jpeg,.doc,.xlsx,.xls,.pptx,.ppt,.csv,.rtf,.odt,.ods,.odp" multiple>
        <div style="margin-top:8px;color:var(--muted)">PDF, DOCX, TXT, JPG, PNG, XLSX, PPTX, CSV, RTF (Max 50MB each)</div>
        <div id="fileProcessingInfo" style="display:none;margin-top:8px">
          <div class="loading-wrap" id="globalSpinner"><div class="spinner3d"></div><span id="spinnerText">Processing‚Ä¶</span></div>
          <div id="processingFileName" class="tagline"></div>
          <div id="processingStatus"></div>
          <div id="pageProgress" class="tagline"></div>
          <div style="background:rgba(0,0,0,.3);border-radius:10px;overflow:hidden;margin-top:8px">
            <div id="progressBar" style="height:18px;width:0%;background:linear-gradient(90deg,#ffdf6b,#00ff88);text-align:center;color:#000;font-weight:800;transition:width .2s"></div>
          </div>
        </div>
      </div>

      <div class="card col-12" style="margin-top: 20px;">
        <h3>üìö LIBRARY</h3>
        <div id="documentsList"></div>
      </div>
    </section>

    <!-- AGENTS CONFIGURATION -->
    <section id="panel-agents" class="panel">
      <div class="grid">
        <div class="card col-4">
          <h3>üî∑ AI Agent 1</h3>
          <label>API KEY</label>
          <input type="password" id="deepseekKey" placeholder="sk-xxxxxxxx" />
          <div style="display:flex;align-items:center;gap:8px;margin-top:10px">
            <div class="status-dot" id="deepseekStatus"></div>
            <span id="deepseekStatusText">Not configured</span>
          </div>
        </div>
        <div class="card col-4">
          <h3>‚ö° AI Agent 2</h3>
          <label>API KEY</label>
          <input type="password" id="openaiKey" placeholder="sk-xxxxxxxx" />
          <div style="display:flex;align-items:center;gap:8px;margin-top:10px">
            <div class="status-dot" id="openaiStatus"></div>
            <span id="openaiStatusText">Not configured</span>
          </div>
        </div>
        <div class="card col-4">
          <h3>üéØ AI Agent 3</h3>
          <label>API KEY</label>
          <input type="password" id="grokKey" placeholder="xai-xxxxxxxx" />
          <div style="display:flex;align-items:center;gap:8px;margin-top:10px">
            <div class="status-dot" id="grokStatus"></div>
            <span id="grokStatusText">Not configured</span>
          </div>
        </div>
      </div>
      <div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:12px">
        <button class="btn btn-primary" id="connectAgentsBtn">üõ°Ô∏è CONNECT AGENTS</button>
        <button class="btn btn-primary" id="saveConfigBtn">üíæ SAVE CONFIGURATION</button>
        <button class="btn btn-danger" id="disconnectAgentsBtn">üîå DISCONNECT AGENTS</button>
      </div>
    </section>

    <div class="card" style="margin-top:12px;display:flex;align-items:center;gap:10px">
      <div class="status-dot" id="globalStatus"></div>
      <span id="statusText">BATHALA INTELLIGENCE: Configure AI Agents to begin</span>
    </div>

    <footer>¬© 2025 by Dimax Technologies Center. Powered and secured by RP8</footer>
  </main>
</div>

<div class="toast-stack" id="toastStack"></div>

<script>
// ===== Utilities
const $ = (q) => document.querySelector(q);
const $$ = (q) => document.querySelectorAll(q);
const byId = (id) => document.getElementById(id);
const show = (el) => { if(el) el.style.display = ''; };
const hide = (el) => { if(el) el.style.display = 'none'; };

function toast(msg, type = 'success') {
  const stack = $('#toastStack');
  const item = document.createElement('div');
  item.className = `toast ${type}`;

  const dot = document.createElement('div');
  dot.className = 'dot';
  dot.style.background = type === 'success' ? 'var(--neon)' :
                        type === 'error' ? 'var(--error)' : 'var(--warn)';

  const span = document.createElement('div');
  span.innerHTML = msg;

  item.append(dot, span);
  stack.appendChild(item);

  setTimeout(() => {
    item.style.opacity = '0';
    item.style.transform = 'translateY(8px)';
  }, 2600);

  setTimeout(() => item.remove(), 3100);
}

// PDF.js worker
pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';

// ===== Hybrid Database Connection Management
const DATABASE_TEMPLATES = {
  // ===== FILE-BASED DATABASES (Direct Browser Access) =====
  sqlite: {
    name: 'SQLite Database File',
    icon: 'üóÉÔ∏è',
    type: 'file',
    connectionType: 'direct',
    description: 'Connect to SQLite database files - perfect for NAS storage',
    fields: [
      { name: 'name', label: 'Connection Name', placeholder: 'My SQLite Database', type: 'text', required: true },
      { name: 'filePath', label: 'SQLite File', placeholder: 'Select .db, .sqlite, or .sqlite3 file', type: 'file', accept: '.db,.sqlite,.sqlite3', required: true },
      { name: 'description', label: 'Description', placeholder: 'e.g., Customer database from NAS storage', type: 'textarea' }
    ]
  },
  
  excel: {
    name: 'Excel File',
    icon: 'üìä',
    type: 'file',
    connectionType: 'direct',
    description: 'Connect to Excel files (.xlsx, .xls) - direct browser access',
    fields: [
      { name: 'name', label: 'Connection Name', placeholder: 'My Excel Database', type: 'text', required: true },
      { name: 'filePath', label: 'Excel File', placeholder: 'Select .xlsx or .xls file', type: 'file', accept: '.xlsx,.xls', required: true },
      { name: 'description', label: 'Description', placeholder: 'e.g., Sales data spreadsheet', type: 'textarea' }
    ]
  },
  
  csv: {
    name: 'CSV File',
    icon: 'üìã',
    type: 'file',
    connectionType: 'direct',
    description: 'Connect to CSV files - direct browser access',
    fields: [
      { name: 'name', label: 'Connection Name', placeholder: 'My CSV Database', type: 'text', required: true },
      { name: 'filePath', label: 'CSV File', placeholder: 'Select .csv file', type: 'file', accept: '.csv', required: true },
      { name: 'description', label: 'Description', placeholder: 'e.g., Customer data export', type: 'textarea' }
    ]
  },
  
  // ===== SERVER DATABASES (Require Backend API) =====
  postgresql: {
    name: 'PostgreSQL Server',
    icon: 'üêò',
    type: 'server',
    connectionType: 'backend',
    description: 'Connect to PostgreSQL server (requires backend API)',
    fields: [
      { name: 'name', label: 'Connection Name', placeholder: 'NAS PostgreSQL Server', type: 'text', required: true },
      { name: 'host', label: 'Server Host', placeholder: '192.168.1.100 (your NAS IP)', type: 'text', required: true },
      { name: 'port', label: 'Port', placeholder: '5432', type: 'text', default: '5432', required: true },
      { name: 'database', label: 'Database Name', type: 'text', required: true },
      { name: 'username', label: 'Username', type: 'text', required: true },
      { name: 'password', label: 'Password', type: 'password', required: true },
      { name: 'description', label: 'Description', placeholder: 'e.g., Production database on NAS', type: 'textarea' }
    ]
  },
  mysql: {
    name: 'MySQL Server', 
    icon: 'üê¨',
    type: 'server',
    connectionType: 'backend',
    description: 'Connect to MySQL server (requires backend API)',
    fields: [
      { name: 'name', label: 'Connection Name', placeholder: 'NAS MySQL Server', type: 'text', required: true },
      { name: 'host', label: 'Server Host', placeholder: '192.168.1.100 (your NAS IP)', type: 'text', required: true },
      { name: 'port', label: 'Port', placeholder: '3306', type: 'text', default: '3306', required: true },
      { name: 'database', label: 'Database Name', type: 'text', required: true },
      { name: 'username', label: 'Username', type: 'text', required: true },
      { name: 'password', label: 'Password', type: 'password', required: true }
    ]
  },
  oracle: {
    name: 'Oracle Database',
    icon: 'üóÑÔ∏è',
    type: 'server',
    connectionType: 'backend',
    description: 'Connect to Oracle Database (requires backend API)',
    fields: [
      { name: 'name', label: 'Connection Name', placeholder: 'Production Oracle DB', type: 'text', required: true },
      { name: 'host', label: 'Server Host', placeholder: '192.168.1.100 (your NAS IP)', type: 'text', required: true },
      { name: 'port', label: 'Port', placeholder: '1521', type: 'text', default: '1521', required: true },
      { name: 'service', label: 'Service Name', placeholder: 'ORCL', type: 'text', required: true },
      { name: 'username', label: 'Username', type: 'text', required: true },
      { name: 'password', label: 'Password', type: 'password', required: true }
    ]
  },
  mssql: {
    name: 'SQL Server',
    icon: 'üè¢',
    type: 'server',
    connectionType: 'backend',
    description: 'Connect to Microsoft SQL Server (requires backend API)',
    fields: [
      { name: 'name', label: 'Connection Name', placeholder: 'Enterprise SQL Server', type: 'text', required: true },
      { name: 'host', label: 'Server Host', placeholder: '192.168.1.100 (your NAS IP)', type: 'text', required: true },
      { name: 'port', label: 'Port', placeholder: '1433', type: 'text', default: '1433', required: true },
      { name: 'database', label: 'Database Name', type: 'text', required: true },
      { name: 'username', label: 'Username', type: 'text', required: true },
      { name: 'password', label: 'Password', type: 'password', required: true }
    ]
  }
};

// Backend API configuration
const BACKEND_CONFIG = {
  enabled: false, // Set to true when you have backend running
  url: 'http://localhost:3001/api',
  endpoints: {
    test: '/test-database-connection',
    query: '/query-database'
  }
};

class HybridDatabaseManager {
  constructor() {
    this.connections = JSON.parse(localStorage.getItem('bathala_hybrid_databases') || '[]');
    this.nextId = Math.max(0, ...this.connections.map(c => c.id)) + 1;
    this.fileCache = new Map();
  }

  saveConnections() {
    localStorage.setItem('bathala_hybrid_databases', JSON.stringify(this.connections));
  }

  async addConnection(connectionData, file = null) {
    const template = DATABASE_TEMPLATES[connectionData.dbType];
    const newConnection = {
      id: this.nextId++,
      ...connectionData,
      connectionType: template.connectionType,
      status: 'disconnected',
      connectedAt: null,
      lastError: null,
      tables: [],
      databaseInfo: null
    };

    if (file && ['sqlite', 'excel', 'csv'].includes(connectionData.dbType)) {
      const fileContent = await this.readFileAsArrayBuffer(file);
      newConnection.fileName = file.name;
      newConnection.fileSize = file.size;
      newConnection.fileType = file.type;
      newConnection.fileContent = fileContent;
      newConnection.fileLastModified = file.lastModified;
    }

    this.connections.push(newConnection);
    this.saveConnections();
    return newConnection;
  }

  async readFileAsArrayBuffer(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = e => resolve(e.target.result);
      reader.onerror = reject;
      reader.readAsArrayBuffer(file);
    });
  }

  updateConnection(id, updates) {
    const connection = this.connections.find(c => c.id === id);
    if (connection) {
      Object.assign(connection, updates);
      this.saveConnections();
    }
  }

  removeConnection(id) {
    this.connections = this.connections.filter(c => c.id !== id);
    this.saveConnections();
  }

  getConnections() {
    return this.connections;
  }

  getConnection(id) {
    return this.connections.find(c => c.id === id);
  }

  getConnectedDatabases() {
    return this.connections.filter(c => c.status === 'connected');
  }
}

const dbManager = new HybridDatabaseManager();

// Initialize SQL.js for SQLite support
let SQL = null;
async function initSQLite() {
  if (!SQL) {
    SQL = await initSqlJs({
      locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/${file}`
    });
  }
  return SQL;
}

// Database connection testing
async function testDatabaseConnection(connection) {
  const template = DATABASE_TEMPLATES[connection.dbType];
  
  if (template.connectionType === 'direct') {
    return await testFileDatabaseConnection(connection);
  } else {
    return await testServerDatabaseConnection(connection);
  }
}

// File database connection testing (SQLite, Excel, CSV)
async function testFileDatabaseConnection(connection) {
  try {
    switch (connection.dbType) {
      case 'sqlite':
        return await testSQLiteConnection(connection);
      case 'excel':
        return await testExcelConnection(connection);
      case 'csv':
        return await testCSVConnection(connection);
      default:
        throw new Error(`Unsupported file database type: ${connection.dbType}`);
    }
  } catch (error) {
    return {
      success: false,
      message: error.message
    };
  }
}

// Server database connection testing (via Backend)
async function testServerDatabaseConnection(connection) {
  if (!BACKEND_CONFIG.enabled) {
    return {
      success: false,
      message: `‚ùå Backend API not configured\n\nTo connect to ${connection.dbType}:\n\n1. Set up Bathala backend on your NAS/local server\n2. Enable backend in settings\n3. Update backend API URL\n\nQuick alternative: Export your database to SQLite format for direct connection.`
    };
  }

  try {
    // Simulate backend connection for demo
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve({
          success: true,
          message: `‚úÖ Connected to ${connection.dbType} via backend`,
          tables: [
            { name: 'users', rows: 1500, columns: ['id', 'name', 'email'] },
            { name: 'products', rows: 850, columns: ['id', 'name', 'price'] }
          ],
          databaseInfo: {
            version: `${connection.dbType} Server`,
            totalTables: 2,
            totalRows: 2350
          }
        });
      }, 2000);
    });
  } catch (error) {
    return {
      success: false,
      message: `Backend connection failed: ${error.message}`
    };
  }
}

// SQLite connection handler
async function testSQLiteConnection(connection) {
  try {
    if (!connection.fileContent) {
      throw new Error('SQLite file not loaded');
    }

    const SQL = await initSQLite();
    const db = new SQL.Database(new Uint8Array(connection.fileContent));
    
    const tablesResult = db.exec(`
      SELECT name FROM sqlite_master 
      WHERE type='table' AND name NOT LIKE 'sqlite_%'
      ORDER BY name
    `);
    
    const tables = tablesResult[0]?.values?.map(row => row[0]) || [];
    const tableInfo = [];
    let totalRows = 0;

    for (const tableName of tables) {
      const countResult = db.exec(`SELECT COUNT(*) as count FROM "${tableName}"`);
      const rowCount = countResult[0]?.values[0][0] || 0;
      totalRows += rowCount;
      
      const columnsResult = db.exec(`PRAGMA table_info("${tableName}")`);
      const columns = columnsResult[0]?.values?.map(row => row[1]) || [];
      
      tableInfo.push({ 
        name: tableName, 
        rows: rowCount,
        columns: columns
      });
    }

    db.close();

    return {
      success: true,
      message: `SQLite database loaded successfully`,
      tables: tableInfo,
      rowCount: totalRows,
      databaseInfo: {
        fileSize: (connection.fileSize / 1024 / 1024).toFixed(2) + ' MB',
        tablesCount: tables.length,
        totalRows: totalRows
      }
    };
  } catch (error) {
    throw new Error(`Invalid SQLite file: ${error.message}`);
  }
}

// Excel connection handler
async function testExcelConnection(connection) {
  try {
    if (!connection.fileContent) {
      throw new Error('Excel file not loaded');
    }

    const data = new Uint8Array(connection.fileContent);
    const workbook = XLSX.read(data, { type: 'array' });
    
    const tableInfo = [];
    let totalRows = 0;

    workbook.SheetNames.forEach(sheetName => {
      const worksheet = workbook.Sheets[sheetName];
      const jsonData = XLSX.utils.sheet_to_json(worksheet);
      const rowCount = jsonData.length;
      totalRows += rowCount;
      
      const columns = [];
      if (jsonData.length > 0) {
        columns.push(...Object.keys(jsonData[0]));
      }
      
      tableInfo.push({
        name: sheetName,
        rows: rowCount,
        columns: columns
      });
    });

    return {
      success: true,
      message: `Excel file loaded successfully`,
      tables: tableInfo,
      rowCount: totalRows,
      databaseInfo: {
        fileSize: (connection.fileSize / 1024 / 1024).toFixed(2) + ' MB',
        sheetsCount: workbook.SheetNames.length,
        totalRows: totalRows
      }
    };
  } catch (error) {
    throw new Error(`Invalid Excel file: ${error.message}`);
  }
}

// CSV connection handler
async function testCSVConnection(connection) {
  try {
    if (!connection.fileContent) {
      throw new Error('CSV file not loaded');
    }

    const text = new TextDecoder().decode(connection.fileContent);
    const lines = text.split('\n').filter(line => line.trim());
    
    if (lines.length === 0) {
      throw new Error('CSV file is empty');
    }

    const headers = lines[0].split(',').map(h => h.trim());
    const rowCount = lines.length - 1;

    return {
      success: true,
      message: `CSV file loaded successfully`,
      tables: [{
        name: 'CSV Data',
        rows: rowCount,
        columns: headers
      }],
      rowCount: rowCount,
      databaseInfo: {
        fileSize: (connection.fileSize / 1024 / 1024).toFixed(2) + ' MB',
        sheetsCount: 1,
        totalRows: rowCount,
        columnsCount: headers.length
      }
    };
  } catch (error) {
    throw new Error(`Invalid CSV file: ${error.message}`);
  }
}

// Database connection functions
async function connectDatabase(connectionId) {
  const connection = dbManager.getConnection(connectionId);
  if (!connection) return;

  try {
    dbManager.updateConnection(connectionId, {
      status: 'connecting',
      connectedAt: null,
      lastError: null
    });
    renderDatabaseConnections();

    const result = await testDatabaseConnection(connection);
    
    if (result.success) {
      dbManager.updateConnection(connectionId, {
        status: 'connected',
        connectedAt: new Date().toISOString(),
        lastError: null,
        tables: result.tables || [],
        databaseInfo: result.databaseInfo
      });
      renderDatabaseConnections();
      
      const template = DATABASE_TEMPLATES[connection.dbType];
      const connectionType = template.connectionType === 'direct' ? 'direct file connection' : 'backend connection';
      toast(`‚úÖ Connected to ${connection.name} via ${connectionType}. Found ${result.tables?.length || 0} tables.`, 'success');
    } else {
      throw new Error(result.message || 'Connection failed');
    }
  } catch (error) {
    dbManager.updateConnection(connectionId, {
      status: 'disconnected',
      connectedAt: null,
      lastError: error.message
    });
    renderDatabaseConnections();
    toast(`‚ùå Failed to connect to ${connection.name}: ${error.message}`, 'error');
  }
}

async function testDatabase(connectionId) {
  const connection = dbManager.getConnection(connectionId);
  if (!connection) return;

  try {
    const statusDot = byId(`dbStatus-${connectionId}`);
    const statusText = byId(`dbStatusText-${connectionId}`);
    
    if (statusDot && statusText) {
      statusDot.className = 'status-dot connecting';
      statusText.textContent = 'Testing...';
    }

    const template = DATABASE_TEMPLATES[connection.dbType];
    const connectionType = template.connectionType === 'direct' ? 'file' : 'server';
    
    toast(`üß™ Testing ${connectionType} connection to ${connection.name}...`, 'success');
    
    const result = await testDatabaseConnection(connection);
    
    if (result.success) {
      toast(`‚úÖ Connection test successful for ${connection.name}`, 'success');
      
      dbManager.updateConnection(connectionId, {
        databaseInfo: result.databaseInfo,
        lastError: null
      });
    } else {
      throw new Error(result.message || 'Connection test failed');
    }
  } catch (error) {
    toast(`‚ùå Connection test failed for ${connection.name}: ${error.message}`, 'error');
    
    dbManager.updateConnection(connectionId, {
      lastError: error.message
    });
  } finally {
    renderDatabaseConnections();
  }
}

async function disconnectDatabase(connectionId) {
  const connection = dbManager.getConnection(connectionId);
  if (!connection) return;

  dbManager.updateConnection(connectionId, {
    status: 'disconnected',
    connectedAt: null
  });

  renderDatabaseConnections();
  toast(`Disconnected from ${connection.name}`, 'warn');
}

function removeDatabase(connectionId) {
  const connection = dbManager.getConnection(connectionId);
  if (!connection) return;

  if (confirm(`Are you sure you want to remove the connection "${connection.name}"?`)) {
    dbManager.removeConnection(connectionId);
    renderDatabaseConnections();
    toast(`Database connection "${connection.name}" removed`, 'warn');
  }
}

// Render database connections
function renderDatabaseConnections() {
  const container = byId('databaseConnections');
  const connections = dbManager.getConnections();

  if (connections.length === 0) {
    container.innerHTML = `
      <div class="col-12" style="text-align: center; padding: 40px; color: var(--muted);">
        <div style="font-size: 3rem; margin-bottom: 16px;">üîó</div>
        <h3>No Database Connections</h3>
        <p>Click "Add Database Connection" to get started</p>
      </div>
    `;
    return;
  }

  container.innerHTML = connections.map(conn => {
    const template = DATABASE_TEMPLATES[conn.dbType];
    const isFileDB = template.connectionType === 'direct';
    const hasError = conn.lastError && conn.status !== 'connected';
    
    let dbTypeClass, dbTypeText;
    if (isFileDB) {
      dbTypeClass = 'db-type-file';
      dbTypeText = 'File Database';
    } else {
      dbTypeClass = conn.status === 'connected' ? 'db-type-server' : 'db-type-backend';
      dbTypeText = conn.status === 'connected' ? 'Server Database' : 'Backend Required';
    }

    return `
    <div class="db-connection-card" data-connection-id="${conn.id}">
      <div class="db-header">
        <div>
          <span class="db-icon">${template.icon}</span>
          <strong>${conn.name}</strong>
          <div style="font-size: 0.8rem; color: var(--muted); display: flex; align-items: center; gap: 8px; margin-top: 4px;">
            <span>${template.name}</span>
            <span class="db-type-badge ${dbTypeClass}">${dbTypeText}</span>
            ${isFileDB && conn.fileName ? `<span>‚Ä¢ ${conn.fileName}</span>` : ''}
            ${!isFileDB ? `<span>‚Ä¢ ${conn.host}:${conn.port}</span>` : ''}
          </div>
        </div>
        <div class="db-status">
          <div class="status-dot ${conn.status === 'connected' ? 'connected' : conn.status === 'connecting' ? 'connecting' : ''}"
               id="dbStatus-${conn.id}"></div>
          <span id="dbStatusText-${conn.id}">
            ${conn.status === 'connected' ? 'Connected' : 
              conn.status === 'connecting' ? 'Connecting...' : 'Disconnected'}
          </span>
        </div>
      </div>

      <div class="connection-form">
        ${hasError ? `
        <div style="margin-bottom: 12px; padding: 10px; background: rgba(255,68,68,.1); border: 1px solid var(--error); border-radius: 6px;">
          <strong>Connection Error:</strong> 
          <div style="font-size: 0.8rem; margin-top: 4px;">${conn.lastError}</div>
        </div>
        ` : ''}

        ${isFileDB ? `
          <div>
            <label>File Name</label>
            <input type="text" value="${conn.fileName || 'No file'}" disabled style="background: rgba(0,0,0,.25);">
          </div>
        ` : `
          <div class="form-row">
            <div>
              <label>Host</label>
              <input type="text" value="${conn.host}" disabled style="background: rgba(0,0,0,.25);">
            </div>
            <div>
              <label>Port</label>
              <input type="text" value="${conn.port}" disabled style="background: rgba(0,0,0,.25);">
            </div>
          </div>
          <div class="form-row">
            <div>
              <label>Database</label>
              <input type="text" value="${conn.database || conn.service || ''}" disabled style="background: rgba(0,0,0,.25);">
            </div>
            <div>
              <label>Username</label>
              <input type="text" value="${conn.username}" disabled style="background: rgba(0,0,0,.25);">
            </div>
          </div>
        `}

        <div style="margin-top: 12px;">
          <label>Description</label>
          <textarea disabled style="background: rgba(0,0,0,.25);">${conn.description || 'No description provided'}</textarea>
        </div>

        ${conn.databaseInfo ? `
        <div style="margin-top: 8px; padding: 8px; background: rgba(0,255,136,.1); border-radius: 6px; font-size: 0.8rem;">
          <strong>Database Info:</strong> ${conn.databaseInfo.tablesCount || conn.databaseInfo.sheetsCount || 0} ${conn.dbType === 'excel' ? 'sheets' : 'tables'}, ${conn.databaseInfo.totalRows || 0} rows
          ${conn.databaseInfo.fileSize ? ` ‚Ä¢ ${conn.databaseInfo.fileSize}` : ''}
        </div>
        ` : ''}

        <div class="form-row" style="margin-top: 16px;">
          <button class="btn ${conn.status === 'connected' ? 'btn-danger' : 'btn-success'}"
                  onclick="${conn.status === 'connected' ? `disconnectDatabase(${conn.id})` : `connectDatabase(${conn.id})`}">
            ${conn.status === 'connected' ? 'üîå Disconnect' : 'üîó Connect'}
          </button>
          <button class="btn btn-warning" onclick="testDatabase(${conn.id})">
            üß™ Test Connection
          </button>
          <button class="btn btn-danger" onclick="removeDatabase(${conn.id})">
            üóëÔ∏è Remove
          </button>
        </div>

        ${conn.status === 'connected' ? `
        <div style="margin-top: 8px; padding: 8px; background: rgba(0,255,136,.1); border-radius: 6px; font-size: 0.8rem;">
          ‚úÖ Connected since ${new Date(conn.connectedAt).toLocaleString()}
          ${conn.tables.length > 0 ? `‚Ä¢ ${conn.tables.length} ${conn.dbType === 'excel' ? 'sheets' : 'tables'} available` : ''}
        </div>
        ` : ''}

        ${!isFileDB && conn.status !== 'connected' ? `
        <div style="margin-top: 8px; padding: 8px; background: rgba(255,165,0,.1); border-radius: 6px; font-size: 0.8rem;">
          <strong>Backend Required:</strong> This database type requires the Bathala backend server to be running on your NAS/local network.
        </div>
        ` : ''}
      </div>
    </div>
    `;
  }).join('');
}

// Show add connection modal
function showAddConnectionModal() {
  const modalHtml = `
    <div style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,.8); display: flex; align-items: center; justify-content: center; z-index: 10000;">
      <div style="background: var(--card); border: 2px solid var(--neon); border-radius: 16px; padding: 24px; max-width: 500px; width: 90%; max-height: 90vh; overflow-y: auto;">
        <h3 style="margin-bottom: 20px;">‚ûï Add Database Connection</h3>

        <div style="margin-bottom: 20px;">
          <label>Select Database Type</label>
          <select id="dbTypeSelect" style="width: 100%; margin-bottom: 16px;">
            <option value="">Choose a database type...</option>
            <optgroup label="File Databases (Direct Connection)">
              <option value="sqlite">üóÉÔ∏è SQLite Database File</option>
              <option value="excel">üìä Excel File</option>
              <option value="csv">üìã CSV File</option>
            </optgroup>
            <optgroup label="Server Databases (Backend Required)">
              <option value="postgresql">üêò PostgreSQL Server</option>
              <option value="mysql">üê¨ MySQL Server</option>
              <option value="oracle">üóÑÔ∏è Oracle Database</option>
              <option value="mssql">üè¢ SQL Server</option>
            </optgroup>
          </select>
        </div>

        <div id="connectionFormContainer"></div>

        <div style="display: flex; gap: 10px; margin-top: 20px;">
          <button class="btn btn-primary" onclick="createConnection()" style="flex: 1;">Create Connection</button>
          <button class="btn btn-danger" onclick="closeModal()" style="flex: 1;">Cancel</button>
        </div>
      </div>
    </div>
  `;

  const modal = document.createElement('div');
  modal.innerHTML = modalHtml;
  modal.id = 'connectionModal';
  document.body.appendChild(modal);

  byId('dbTypeSelect').addEventListener('change', function() {
    renderConnectionForm(this.value);
  });
}

function closeModal() {
  const modal = byId('connectionModal');
  if (modal) modal.remove();
}

function renderConnectionForm(dbType) {
  const container = byId('connectionFormContainer');
  if (!dbType) {
    container.innerHTML = '<p style="color: var(--muted); text-align: center;">Please select a database type</p>';
    return;
  }

  const template = DATABASE_TEMPLATES[dbType];
  const isFileDB = template.connectionType === 'direct';
  
  const fieldsHtml = template.fields.map(field => {
    if (field.type === 'file') {
      return `
      <div style="margin-bottom: 12px;">
        <label>${field.label} ${field.required ? '<span style="color: var(--error)">*</span>' : ''}</label>
        <input type="file"
               id="dbField_${field.name}"
               accept="${field.accept}"
               ${field.required ? 'required' : ''}
               style="width: 100%; padding: 8px; border: 1px solid var(--neon); border-radius: 8px; background: rgba(0,0,0,.45); color: #fff;">
      </div>
      `;
    } else if (field.type === 'textarea') {
      return `
      <div style="margin-bottom: 12px;">
        <label>${field.label} ${field.required ? '<span style="color: var(--error)">*</span>' : ''}</label>
        <textarea id="dbField_${field.name}"
                  placeholder="${field.placeholder || ''}"
                  ${field.required ? 'required' : ''}
                  style="width: 100%; min-height: 60px;">${field.default || ''}</textarea>
      </div>
      `;
    } else {
      return `
      <div style="margin-bottom: 12px;">
        <label>${field.label} ${field.required ? '<span style="color: var(--error)">*</span>' : ''}</label>
        <input type="${field.type}"
               id="dbField_${field.name}"
               placeholder="${field.placeholder || ''}"
               value="${field.default || ''}"
               ${field.required ? 'required' : ''}
               style="width: 100%;">
      </div>
      `;
    }
  }).join('');

  const connectionInfo = isFileDB ? 
    '‚úÖ Direct browser connection - perfect for NAS storage' :
    'üîß Requires Bathala backend server on your NAS/local network';

  container.innerHTML = `
    <div style="margin-bottom: 16px; padding: 12px; background: ${isFileDB ? 'rgba(0,255,136,.05)' : 'rgba(255,165,0,.05)'}; border-radius: 8px;">
      <strong>${template.icon} ${template.name}</strong>
      <div style="font-size: 0.8rem; color: var(--muted); margin-top: 4px;">${template.description}</div>
      <div style="font-size: 0.7rem; margin-top: 6px; padding: 4px; background: ${isFileDB ? 'rgba(0,255,136,.1)' : 'rgba(255,165,0,.1)'}; border-radius: 4px;">
        ${connectionInfo}
      </div>
    </div>
    ${fieldsHtml}
  `;
}

async function createConnection() {
  const dbType = byId('dbTypeSelect').value;
  if (!dbType) {
    toast('Please select a database type', 'error');
    return;
  }

  const template = DATABASE_TEMPLATES[dbType];
  const connectionData = {
    dbType: dbType,
    name: byId('dbField_name')?.value,
    description: byId('dbField_description')?.value,
    icon: template.icon,
    type: template.name
  };

  // Add specific fields based on database type
  if (template.connectionType === 'direct') {
    const fileInput = byId('dbField_filePath');
    if (!fileInput?.files[0]) {
      toast('Please select a database file', 'error');
      return;
    }
  } else {
    // Server database fields
    connectionData.host = byId('dbField_host')?.value;
    connectionData.port = byId('dbField_port')?.value;
    connectionData.database = byId('dbField_database')?.value;
    connectionData.service = byId('dbField_service')?.value;
    connectionData.username = byId('dbField_username')?.value;
    connectionData.password = byId('dbField_password')?.value;
  }

  // Validate required fields
  for (const field of template.fields) {
    if (field.required) {
      const value = field.type === 'file' 
        ? byId(`dbField_${field.name}`)?.files[0]
        : byId(`dbField_${field.name}`)?.value;
      
      if (!value) {
        toast(`Please fill in the ${field.label} field`, 'error');
        return;
      }
    }
  }

  try {
    let file = null;
    if (template.connectionType === 'direct') {
      file = byId('dbField_filePath').files[0];
    }

    await dbManager.addConnection(connectionData, file);
    renderDatabaseConnections();
    closeModal();
    
    const connectionType = template.connectionType === 'direct' ? 'file database' : 'server database';
    toast(`Database connection "${connectionData.name}" created as ${connectionType}`, 'success');
  } catch (error) {
    toast(`Failed to create connection: ${error.message}`, 'error');
  }
}

// ===== API config - UPDATED FOR PROXY
// Replace 'YOUR-VERCEL-URL' with your actual Vercel URL (e.g., 'bathala-intelligence.vercel.app')
const YOUR_VERCEL_URL = 'YOUR-VERCEL-URL.vercel.app';

const API_CONFIG = {
  deepseek: {
    name: 'AI Agent 1',
    // ‚úÖ Updated to use proxy
    baseURL: `https://${YOUR_VERCEL_URL}/api/proxy`,
    endpoints: { chat: '/deepseek/chat', models: '/deepseek/models' }
  },
  openai: {
    name: 'AI Agent 2',
    // ‚úÖ Updated to use proxy
    baseURL: `https://${YOUR_VERCEL_URL}/api/proxy`,
    endpoints: { chat: '/openai/chat', models: '/openai/models' }
  },
  grok: {
    name: 'AI Agent 3',
    // ‚úÖ Updated to use proxy
    baseURL: `https://${YOUR_VERCEL_URL}/api/proxy`,
    endpoints: { chat: '/grok/chat', models: '/grok/models' }
  }
};

// Persona prompts
const PERSONA = {
  analyst: `You are Bathala (Analyst). Be precise, statistical, cite assumptions, provide numbered steps and short tables when helpful.`,
  ethicist: `You are Bathala (Ethicist). Prioritize safety, fairness, consent, governance impacts. Highlight tradeoffs and ethical risks.`,
  strategist: `You are Bathala (Strategist). Optimize for impact. Provide action plans, decision trees, and clear prioritization.`,
  creative: `You are Bathala (Creative). Provide novel ideas, metaphors, and multiple alternatives. Keep it practical.`
};

// ===== Sidebar navigation
function activatePanel(name) {
  document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
  const panel = document.querySelector(`#panel-${name}`);
  if (panel) {
    panel.classList.add('active');
  } else {
    console.warn(`Panel not found: ${name}`);
  }
}

document.querySelectorAll('.nav button').forEach(button => {
  button.addEventListener('click', () => {
    document.querySelectorAll('.nav button').forEach(b => b.classList.remove('active'));
    button.classList.add('active');
    const target = button.getAttribute('data-panel');
    activatePanel(target);
  });
});

console.log('Bathala v4.0: Navigation system loaded.');

// ===== Status helpers
function updateApiStatus(provider, status, message) {
  const dot = byId(`${provider}Status`);
  const text = byId(`${provider}StatusText`);
  if (!dot || !text) return;

  switch (status) {
    case 'connected':
      dot.className = 'status-dot connected';
      text.textContent = 'Connected ‚úì';
      text.style.color = 'var(--neon)';
      break;
    case 'saved':
      dot.className = 'status-dot';
      text.textContent = 'Configured (not tested)';
      text.style.color = 'var(--warn)';
      break;
    case 'error':
      dot.className = 'status-dot';
      text.textContent = message || 'Connection failed';
      text.style.color = 'var(--error)';
      break;
    default:
      dot.className = 'status-dot';
      text.textContent = 'Not configured';
      text.style.color = '#ccc';
  }
}

function loadApiKeys() {
  ['deepseek', 'openai', 'grok'].forEach(p => {
    const k = localStorage.getItem(`${p}_api_key`);
    if (k) {
      const el = byId(`${p}Key`);
      if (el) el.value = k;
      updateApiStatus(p, 'saved');
    }
  });
}

async function testApiConnection(provider) {
  const apiKeyEl = byId(`${provider}Key`);
  const apiKey = apiKeyEl?.value;

  if (!apiKey) {
    updateApiStatus(provider, 'error', 'No API key provided');
    return false;
  }

  try {
    const res = await fetch(
      `${API_CONFIG[provider].baseURL}${API_CONFIG[provider].endpoints.models}`,
      { 
        headers: { 
          'Authorization': `Bearer ${apiKey}`,
          'Content-Type': 'application/json'
        }
      }
    );

    if (res.ok) {
      updateApiStatus(provider, 'connected');
      return true;
    } else {
      const errorText = await res.text();
      updateApiStatus(provider, 'error', `HTTP ${res.status}: ${errorText.slice(0, 50)}`);
      return false;
    }
  } catch (e) {
    updateApiStatus(provider, 'error', `Network/CORS error: ${e.message}`);
    return false;
  }
}

// ===== Knowledge Base (IndexedDB)
class LocalKnowledgeBase {
  constructor() {
    this.db = null;
    this.ready = this.initDatabase();
  }

  async initDatabase() {
    return new Promise((resolve, reject) => {
      const req = indexedDB.open('BathalaKB_v4', 1);

      req.onerror = () => reject(req.error);
      req.onsuccess = () => { this.db = req.result; resolve(); };

      req.onupgradeneeded = (e) => {
        const db = e.target.result;

        if (!db.objectStoreNames.contains('documents')) {
          const s = db.createObjectStore('documents', { keyPath: 'id' });
          s.createIndex('filename', 'filename');
          s.createIndex('uploadDate', 'uploadDate');
          s.createIndex('searchableContent', 'searchableContent');
          s.createIndex('conversionType', 'conversionType');
        }

        if (!db.objectStoreNames.contains('responses')) {
          const r = db.createObjectStore('responses', { keyPath: 'fingerprint' });
          r.createIndex('createdAt', 'createdAt');
        }

        if (!db.objectStoreNames.contains('history')) {
          const h = db.createObjectStore('history', { keyPath: 'id' });
          h.createIndex('type', 'type');
          h.createIndex('createdAt', 'createdAt');
        }
      };
    });
  }

  async storeDocument(file, fullContent, searchableContent, conversionType) {
    await this.ready;

    const doc = {
      id: `${Date.now()}_${file.name}`,
      filename: file.name,
      content: fullContent,
      searchableContent: (searchableContent || '').toLowerCase(),
      uploadDate: new Date(),
      fileType: file.type,
      size: file.size,
      wordCount: (searchableContent || '').split(/\s+/).filter(Boolean).length,
      storagePath: 'Ai CHIP',
      conversionType: conversionType || 'Direct Processing'
    };

    const tx = this.db.transaction(['documents'], 'readwrite');
    const store = tx.objectStore('documents');
    await store.put(doc);
    return doc;
  }

  async getAllDocuments() {
    await this.ready;
    const tx = this.db.transaction(['documents'], 'readonly');
    const st = tx.objectStore('documents');

    return new Promise((resolve, reject) => {
      const r = st.getAll();
      r.onsuccess = () => resolve(r.result);
      r.onerror = () => reject(r.error);
    });
  }

  async deleteDocument(id) {
    await this.ready;
    const tx = this.db.transaction(['documents'], 'readwrite');
    const st = tx.objectStore('documents');

    return new Promise((resolve, reject) => {
      const r = st.delete(id);
      r.onsuccess = () => resolve();
      r.onerror = () => reject(r.error);
    });
  }

  async searchDocuments(query) {
    await this.ready;
    const docs = await this.getAllDocuments();
    if (docs.length === 0) return [];

    const terms = query.toLowerCase().split(/\s+/).filter(t => t.length > 2);
    const results = [];

    for (const d of docs) {
      const content = d.content.toLowerCase();
      const search = d.searchableContent || '';
      const fname = d.filename.toLowerCase();
      let score = 0;

      for (const t of terms) {
        if (fname.includes(t)) score += 15;

        const cm = (content.match(new RegExp(t, 'gi')) || []).length;
        if (cm > 0) score += cm * 2;

        const sm = (search.match(new RegExp(t, 'gi')) || []).length;
        if (sm > 0) score += sm * 5;
      }

      if (content.includes(query.toLowerCase())) score += 50;
      if (score > 0) results.push({ d, score });
    }

    return results.sort((a, b) => b.score - a.score).map(r => r.d);
  }

  async putResponse(fingerprint, payload) {
    await this.ready;
    const tx = this.db.transaction(['responses'], 'readwrite');
    const st = tx.objectStore('responses');
    await st.put({ fingerprint, payload, createdAt: Date.now() });
  }

  async getResponse(fingerprint) {
    await this.ready;
    const tx = this.db.transaction(['responses'], 'readonly');
    const st = tx.objectStore('responses');

    return new Promise((resolve) => {
      const r = st.get(fingerprint);
      r.onsuccess = () => resolve(r.result?.payload || null);
      r.onerror = () => resolve(null);
    });
  }

  async pushHistory(entry) {
    await this.ready;
    const id = `${Date.now()}_${Math.random().toString(36).slice(2, 7)}`;
    const tx = this.db.transaction(['history'], 'readwrite');
    const st = tx.objectStore('history');
    await st.put({ id, ...entry, createdAt: Date.now() });
  }

  async listHistory(type, limit = 8) {
    await this.ready;
    const tx = this.db.transaction(['history'], 'readonly');
    const st = tx.objectStore('history');
    const idx = st.index('createdAt');

    return new Promise((resolve) => {
      const out = [];
      idx.openCursor(null, 'prev').onsuccess = (e) => {
        const cur = e.target.result;
        if (cur) {
          if (!type || cur.value.type === type) {
            out.push(cur.value);
            if (out.length >= limit) return resolve(out);
          }
          cur.continue();
        } else {
          resolve(out);
        }
      };
    });
  }
}

const knowledgeBase = new LocalKnowledgeBase();

// Simple SHA-256 fingerprint
async function fingerprintOf(obj) {
  const enc = new TextEncoder().encode(JSON.stringify(obj));
  const digest = await crypto.subtle.digest('SHA-256', enc);
  return Array.from(new Uint8Array(digest)).map(b => b.toString(16).padStart(2, '0')).join('');
}

// ===== File Processor
class FileProcessor {
  showProgress() {
    const info = byId('fileProcessingInfo');
    if (info) info.style.display = 'block';

    const sp = byId('globalSpinner');
    if (sp) sp.classList.add('active');
  }

  hideProgress() {
    const sp = byId('globalSpinner');
    if (sp) sp.classList.remove('active');

    const bar = byId('progressBar');
    if (bar) {
      bar.style.width = '0%';
      bar.textContent = '';
    }

    const info = byId('fileProcessingInfo');
    if (info) {
      setTimeout(() => {
        info.style.display = 'none';
        byId('spinnerText').textContent = 'Processing‚Ä¶';
      }, 500);
    }
  }

  updateProgress(name, status, percent, cur = 0, total = 0, ocr = 0) {
    byId('processingFileName').textContent = `Processing: ${name}`;
    byId('processingStatus').textContent = status;
    byId('pageProgress').textContent = total ? `Page ${cur} of ${total} ‚Ä¢ OCR: ${ocr}` : '';

    const bar = byId('progressBar');
    const sp = byId('globalSpinner');
    const st = byId('spinnerText');

    if (bar) {
      bar.style.width = `${percent}%`;
      bar.textContent = `${Math.round(percent)}%`;

      if (percent < 50) {
        bar.style.background = 'linear-gradient(90deg, #ff6b6b, #ffdf6b)';
      } else if (percent < 100) {
        bar.style.background = 'linear-gradient(90deg, #ffdf6b, #00cc6a)';
      } else {
        bar.style.background = 'linear-gradient(90deg, #00cc6a, #00ff88)';
      }
    }

    if (percent >= 100) {
      if (sp) sp.classList.remove('active');
      if (st) st.textContent = 'Completed';
      setTimeout(() => { this.hideProgress(); }, 900);
    }
  }

  async processPDF(file) {
    try {
      const buf = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({ data: buf }).promise;
      let text = '';
      const total = pdf.numPages;
      let ocrPages = 0;
      let textPages = 0;

      const worker = await Tesseract.createWorker('eng');

      for (let n = 1; n <= total; n++) {
        this.updateProgress(file.name, `Processing page ${n}/${total}`, ((n - 1) / total) * 70 + 30, n, total, ocrPages);

        const page = await pdf.getPage(n);
        const tc = await page.getTextContent();
        const pt = tc.items.map(i => i.str).join(' ');

        if (pt.trim().length > 10) {
          text += `Page ${n}: ${pt}\n\n`;
          textPages++;
        } else {
          const vp = page.getViewport({ scale: 3 });
          const c = document.createElement('canvas');
          const ctx = c.getContext('2d');
          c.width = vp.width;
          c.height = vp.height;

          await page.render({ canvasContext: ctx, viewport: vp }).promise;
          const { data: { text: ocrText } } = await worker.recognize(c);
          ocrPages++;
          text += `[OCR Page ${n}]: ${ocrText}\n\n`;
        }
      }

      await worker.terminate();
      this.updateProgress(file.name, 'PDF conversion completed!', 100, total, total, ocrPages);

      return {
        text: text || '[No readable text]',
        info: `PDF ${total} pages, ${textPages} text, ${ocrPages} OCR`,
        conversionType: ocrPages > 0 ? 'OCR Enhanced' : 'Direct Text Extraction'
      };
    } catch (e) {
      this.updateProgress(file.name, 'PDF conversion failed', 100);
      return {
        text: '[PDF processing failed]',
        info: 'PDF processing error',
        conversionType: 'Failed'
      };
    }
  }

  async extractText(file) {
    try {
      if (file.size > 50 * 1024 * 1024) {
        return {
          success: false,
          content: `File "${file.name}" is too large.`,
          extractedText: ''
        };
      }

      this.showProgress();
      this.updateProgress(file.name, 'Starting‚Ä¶', 10);

      if (file.type.includes('pdf') || file.name.toLowerCase().endsWith('.pdf')) {
        const r = await this.processPDF(file);
        return {
          success: true,
          content: this.buildMeta(file, r.info, r.conversionType) + "\n\n" + r.text,
          extractedText: r.text,
          conversionType: r.conversionType
        };
      }

      if (file.type.includes('image')) {
        this.updateProgress(file.name, 'OCR on image‚Ä¶', 50);
        const worker = await Tesseract.createWorker('eng');
        const { data: { text } } = await worker.recognize(file);
        await worker.terminate();
        this.updateProgress(file.name, 'Completed', 100);

        return {
          success: true,
          content: this.buildMeta(file, 'OCR completed', 'OCR Processing') + "\n\n" + text,
          extractedText: text,
          conversionType: 'OCR Processing'
        };
      }

      if (file.name.toLowerCase().endsWith('.docx')) {
        this.updateProgress(file.name, 'Processing DOCX‚Ä¶', 40);
        const ab = await file.arrayBuffer();
        const r = await mammoth.extractRawText({ arrayBuffer: ab });
        const txt = r.value || 'No text';
        this.updateProgress(file.name, 'Completed', 100);

        return {
          success: true,
          content: this.buildMeta(file, 'DOCX processed', 'Direct Processing') + "\n\n" + txt,
          extractedText: txt,
          conversionType: 'Direct Processing'
        };
      }

      if (file.name.toLowerCase().match(/\.(xlsx|xls)$/)) {
        this.updateProgress(file.name, 'Processing Excel‚Ä¶', 50);
        const ab = await file.arrayBuffer();
        const wb = XLSX.read(new Uint8Array(ab), { type: 'array' });
        let txt = '';

        wb.SheetNames.forEach(s => {
          const ws = wb.Sheets[s];
          txt += `Sheet: ${s}\n` + XLSX.utils.sheet_to_csv(ws) + "\n\n";
        });

        this.updateProgress(file.name, 'Completed', 100);

        return {
          success: true,
          content: this.buildMeta(file, `Excel processed: ${wb.SheetNames.length} sheets`, 'Direct Processing') + "\n\n" + txt,
          extractedText: txt,
          conversionType: 'Direct Processing'
        };
      }

      // Fallback text
      this.updateProgress(file.name, 'Reading text‚Ä¶', 60);
      const txt = await new Promise((resolve) => {
        const r = new FileReader();
        r.onload = e => resolve(e.target.result || '');
        r.readAsText(file);
      });

      this.updateProgress(file.name, 'Completed', 100);

      return {
        success: true,
        content: this.buildMeta(file, 'Text file processed', 'Direct Processing') + "\n\n" + txt,
        extractedText: txt,
        conversionType: 'Direct Processing'
      };
    } catch (e) {
      this.updateProgress(file.name, 'Completed with warnings', 100);
      return {
        success: true,
        content: this.buildMeta(file, 'Processing completed', 'Basic Processing') + "\n\nFile stored successfully.",
        extractedText: 'File stored',
        conversionType: 'Basic Processing'
      };
    }
  }

  buildMeta(file, info, conv) {
    return `FILE: ${file.name}
TYPE: ${file.type}
SIZE: ${(file.size / (1024 * 1024)).toFixed(2)}MB
STORAGE_PATH: Ai CHIP
UPLOAD_DATE: ${new Date().toLocaleString()}
PROCESSING_INFO: ${info}
CONVERSION_TYPE: ${conv}`;
  }

  async processFiles(files) {
    try {
      for (let i = 0; i < files.length; i++) {
        const f = files[i];
        const r = await this.extractText(f);

        if (r.success) {
          await knowledgeBase.storeDocument(f, r.content, r.extractedText, r.conversionType);
          toast(`Stored <b>${f.name}</b> in Library`, 'success');
        } else {
          toast(r.content, 'error');
        }
      }
    } finally {
      this.hideProgress();
      await updateDocumentsList();
    }
  }
}

const fileProcessor = new FileProcessor();

// Documents list renderers
async function renderDocuments(into) {
  if (!into) return;

  const docs = await knowledgeBase.getAllDocuments();
  if (docs.length === 0) {
    into.innerHTML = '<p style="color:#ccc">No documents yet.</p>';
    return;
  }

  let html = '';
  for (let i = 0; i < docs.length; i++) {
    const d = docs[i];
    const idx = i + 1;
    const size = (d.size / (1024 * 1024)).toFixed(2);
    const ocr = d.conversionType === 'OCR Enhanced'
      ? '<span class="badge" style="border-color:var(--violet);color:var(--violet)">OCR</span>'
      : '';

    html += `
    <div style="display:flex;justify-content:space-between;align-items:center;border:1px solid rgba(0,255,136,.35);border-radius:8px;padding:10px;margin:8px 0;background:rgba(0,0,0,.25)">
      <div><strong>${idx}.</strong> üìÑ ${d.filename} ${ocr}
        <div style="color:#aaa;font-size:.85rem">${d.fileType}, ${size}MB, ${d.wordCount} words</div>
      </div>
      <button class="btn btn-danger" onclick="deleteDocument('${d.id}')">üóëÔ∏è Delete</button>
    </div>`;
  }

  into.innerHTML = html;
}

async function updateDocumentsList() {
  await knowledgeBase.ready;
  await renderDocuments(byId('documentsList'));
}

async function deleteDocument(id) {
  await knowledgeBase.deleteDocument(id);
  await updateDocumentsList();
  toast('Document deleted', 'warn');
}

// Highlight search terms
function highlight(text, q) {
  if (!q || !text) return text;

  const terms = q.split(/\s+/).filter(t => t.length > 2);
  let t = text;

  for (const term of terms) {
    const re = new RegExp(`(${term.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')})`, 'gi');
    t = t.replace(re, '<span style="background:yellow;color:#000;border-radius:3px;padding:0 3px">$1</span>');
  }

  return t;
}

// Provider arbitration
function getArbitrationProvider() {
  for (const p of ['openai', 'deepseek', 'grok']) {
    const el = byId(`${p}Key`);
    if (el && el.value) return p;
  }
  return null;
}

// Query AI (with persona + cache)
async function queryAI(provider, query, apiKey, persona) {
  const start = Date.now();
  const system = PERSONA[persona || 'strategist'];
  const model = provider === 'grok' ? 'grok-code-fast-1'
             : provider === 'deepseek' ? 'deepseek-chat'
             : 'gpt-3.5-turbo';

  const fp = await fingerprintOf({ provider, model, persona, query });
  const cached = await knowledgeBase.getResponse(fp);

  if (cached) {
    return { success: true, content: cached.content, responseTime: 0, cached: true };
  }

  try {
    const res = await fetch(`${API_CONFIG[provider].baseURL}${API_CONFIG[provider].endpoints.chat}`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        model,
        messages: [
          { role: 'system', content: system },
          { role: 'user', content: query }
        ],
        max_tokens: 1000,
        temperature: 0.7
      })
    });

    if (!res.ok) {
      const t = await res.text();
      throw new Error(`API ${res.status} - ${t}`);
    }

    const data = await res.json();
    const content = data.choices?.[0]?.message?.content || '[No content]';

    await knowledgeBase.putResponse(fp, { content, at: Date.now() });
    return { success: true, content, responseTime: Date.now() - start };
  } catch (e) {
    return { success: false, error: e.message, responseTime: Date.now() - start };
  }
}

// Combined AI Query (documents + persona)
async function combinedAIQuery(provider, query, apiKey, persona) {
  const relevantDocs = await knowledgeBase.searchDocuments(query);

  if (relevantDocs.length === 0) {
    return {
      success: true,
      content: `‚ùå No matching documents found for: "${query}".\n\nSearch query does not match any content in the local library. Analysis will not proceed to conserve API resources.`,
      responseTime: 0,
      noMatch: true
    };
  }

  let all = '';
  relevantDocs.forEach((d, i) => {
    all += `DOCUMENT ${i + 1}: ${d.filename}\n${(d.searchableContent || '').slice(0, 12000)}\n\n`;
  });

  const enhanced = `${PERSONA[persona || 'strategist']}
Use ONLY the provided document text unless specified.
USER QUERY: ${query}

DOCUMENT DATA:
${all}`;

  return await queryAI(provider, enhanced, apiKey, persona);
}

// Database AI Query (connected databases + persona)
async function databaseAIQuery(provider, query, apiKey, persona) {
  // Get connected databases
  const connectedDbs = dbManager.getConnectedDatabases();
  
  if (connectedDbs.length === 0) {
    return {
      success: true,
      content: `‚ùå No connected databases found. 

Available Connection Options:
1. **SQLite Files**: Upload .db files directly (perfect for NAS storage)
2. **Excel Files**: Upload .xlsx/.xls files directly
3. **CSV Files**: Upload .csv files directly
4. **Server Databases**: PostgreSQL, MySQL, Oracle, SQL Server (requires backend)
5. **Quick Start**: Export server databases to SQLite format

For document search: Use "Bathala Mode" to search your document library instead.`,
      responseTime: 0,
      noMatch: true
    };
  }

  let databaseInfo = 'CONNECTED DATABASES:\n\n';
  
  connectedDbs.forEach((db, i) => {
    const template = DATABASE_TEMPLATES[db.dbType];
    databaseInfo += `DATABASE ${i + 1}: ${db.name} (${template.name})\n`;
    databaseInfo += `Type: ${template.connectionType === 'direct' ? 'File Database' : 'Server Database'}\n`;
    
    if (db.tables && db.tables.length > 0) {
      databaseInfo += `Tables: ${db.tables.slice(0, 5).map(t => t.name).join(', ')}`;
      if (db.tables.length > 5) databaseInfo += `... and ${db.tables.length - 5} more`;
      databaseInfo += '\n';
    }
    
    if (db.databaseInfo) {
      databaseInfo += `Info: ${db.databaseInfo.tablesCount || db.databaseInfo.sheetsCount || 0} ${db.dbType === 'excel' ? 'sheets' : 'tables'}, ${db.databaseInfo.totalRows || 0} rows\n`;
    }
    databaseInfo += '\n';
  });

  const enhanced = `${PERSONA[persona || 'strategist']}

USER QUERY: ${query}

${databaseInfo}

ANALYSIS REQUEST:
Analyze the available database structure and provide insights based on the user's query. 

For file databases (SQLite, Excel, CSV): Suggest what data might be relevant and potential queries.
For server databases: Suggest data relationships and analysis opportunities.

Focus on the database structure and how it relates to the user's query.`;

  return await queryAI(provider, enhanced, apiKey, persona);
}

// Super Mode AI Query (Library + Database + AI Engines)
async function superModeAIQuery(provider, query, apiKey, persona) {
  // Get data from all sources
  const relevantDocs = await knowledgeBase.searchDocuments(query);
  const connectedDbs = dbManager.getConnectedDatabases();
  
  let context = 'SUPER MODE ANALYSIS - INTEGRATED DATA SOURCES:\n\n';

  // Add document context
  if (relevantDocs.length > 0) {
    context += 'üìö LIBRARY DOCUMENTS:\n';
    relevantDocs.forEach((d, i) => {
      context += `DOCUMENT ${i + 1}: ${d.filename}\n${(d.searchableContent || '').slice(0, 8000)}\n\n`;
    });
  } else {
    context += 'üìö LIBRARY: No matching documents found\n\n';
  }

  // Add database context
  if (connectedDbs.length > 0) {
    context += 'üóÉÔ∏è CONNECTED DATABASES:\n';
    connectedDbs.forEach((db, i) => {
      const template = DATABASE_TEMPLATES[db.dbType];
      context += `DATABASE ${i + 1}: ${db.name} (${template.name})\n`;
      context += `Type: ${template.connectionType === 'direct' ? 'File Database' : 'Server Database'}\n`;
      
      if (db.tables && db.tables.length > 0) {
        context += `Tables: ${db.tables.slice(0, 3).map(t => t.name).join(', ')}`;
        if (db.tables.length > 3) context += `... and ${db.tables.length - 3} more`;
        context += '\n';
      }
      
      if (db.databaseInfo) {
        context += `Info: ${db.databaseInfo.tablesCount || db.databaseInfo.sheetsCount || 0} ${db.dbType === 'excel' ? 'sheets' : 'tables'}, ${db.databaseInfo.totalRows || 0} rows\n`;
      }
      context += '\n';
    });
  } else {
    context += 'üóÉÔ∏è DATABASES: No connected databases\n\n';
  }

  // Add AI engine context
  context += 'üß† AI ANALYSIS ENGINES:\n';
  context += '‚Ä¢ Multiple AI models for cross-verification\n';
  context += '‚Ä¢ Real-time data processing\n';
  context += '‚Ä¢ Advanced pattern recognition\n\n';

  const enhanced = `${PERSONA[persona || 'strategist']}

USER QUERY: ${query}

${context}

SUPER MODE ANALYSIS REQUEST:
Perform comprehensive analysis using ALL available data sources. Integrate insights from documents, databases, and AI engines. Provide the most complete and accurate response possible, highlighting connections between different data sources and identifying patterns that wouldn't be visible from individual sources alone.`;

  return await queryAI(provider, enhanced, apiKey, persona);
}

// Forecast AI Query - FIXED FUNCTION
async function forecastAIQuery(provider, query, apiKey, persona) {
  // Get all search results from the current page
  const resultsCards = $$('.response-card');
  if (resultsCards.length === 0) {
    return {
      success: true,
      content: `‚ùå No search results available for forecasting.\n\nPlease perform a search first to generate data for forecasting analysis.`,
      responseTime: 0,
      noMatch: true
    };
  }

  let allResults = 'SEARCH RESULTS FOR FORECASTING ANALYSIS:\n\n';
  
  resultsCards.forEach((card, i) => {
    const providerName = card.querySelector('.provider-badge')?.textContent || `Result ${i + 1}`;
    const content = card.querySelector('.response-content')?.textContent || '';
    
    allResults += `RESULT ${i + 1} (${providerName}):\n${content.slice(0, 5000)}\n\n---\n\n`;
  });

  const enhanced = `${PERSONA[persona || 'strategist']}

FORECASTING ANALYSIS REQUEST:

USER QUERY: ${query}

AVAILABLE DATA:
${allResults}

FORECASTING INSTRUCTIONS:
Based on the search results above, provide a comprehensive 1-5 year forecast. Include:

1. **SHORT-TERM (1-2 years):** Immediate trends, opportunities, and risks
2. **MID-TERM (3-4 years):** Evolving patterns and strategic implications  
3. **LONG-TERM (5+ years):** Transformative changes and paradigm shifts

Structure your response with:
- Key drivers and influencing factors
- Probability assessments for different scenarios
- Recommended actions and contingency plans
- Metrics for tracking progress and validation

Focus on actionable insights and evidence-based projections.`;

  return await queryAI(provider, enhanced, apiKey, persona);
}

// Render responses
function renderCompareResults(query, results) {
  let html = `<h3 style="color:var(--warn);margin-bottom:12px">üöÄ AI SEARCH: \"${query}\"</h3><div class="response-grid">`;
  for(const r of results){
    const body = r.success? r.content : `<div style='color:var(--error)'>‚ùå ${r.error}</div>`;
    const noMatchStyle = r.noMatch ? 'style="border-color: var(--warn); background: rgba(255,165,0,.05);"' : '';
    html += `<div class="response-card" ${noMatchStyle}>
      <div class="response-header"><div class="provider-badge">${API_CONFIG[r.provider].name}</div><div class="response-time">${r.responseTime}ms${r.cached?' ¬∑ cached':''}</div></div>
      <div class="response-content">${body}</div>
    </div>`;
  }
  html+='</div>';
  return html;
}

// Loading helpers for search
function setSearchVisible() {
  const sec = byId('resultsSection');
  if(sec) sec.style.display='';
}

// Search actions + History push
async function performAISearch() {
  const query=byId('searchInput').value.trim();
  const provider=byId('aiProvider').value;
  const persona=byId('personaSelect').value;
  if(!query) return toast('Enter a search query','warn');
  const hasKeys=['deepseek','openai','grok'].some(p=> byId(p+'Key')?.value);
  if(!hasKeys) return toast('Configure at least one AI key','warn');
  setSearchVisible(); byId('resultsArea').innerHTML='';
  byId('statusText').textContent='BATHALA INTELLIGENCE: Executing AI search‚Ä¶';
  if(provider==='compare'){
    const out=[];
    for(const prov of ['deepseek','openai','grok']){
      const key=byId(prov+'Key')?.value;
      if(!key){ out.push({provider:prov, success:false, error:'API key not configured', responseTime:0}); continue;}
      const r=await queryAI(prov, query, key, persona); out.push({provider:prov, ...r});
    }
    const html = renderCompareResults(query, out);
    byId('resultsArea').innerHTML = html;
    byId('checkBalanceBtn').style.display='';
    byId('forecastBtn').style.display='';
    await knowledgeBase.pushHistory({ type:'search', title: query.slice(0,60), payload: html }); await refreshHistory();
  } else {
    const key=byId(provider+'Key')?.value; if(!key) { return toast(`Configure ${API_CONFIG[provider].name} key`,'warn'); }
    const r=await queryAI(provider, query, key, persona);
    const body = r.success? r.content : `<div style='color:var(--error)'>‚ùå ${r.error}</div>`;
    const html = `<div class="response-card">
      <div class="response-header"><div class="provider-badge">${API_CONFIG[provider].name}</div><div class="response-time">${r.responseTime}ms${r.cached?' ¬∑ cached':''}</div></div>
      <div class="response-content">${body}</div>
    </div>`;
    byId('resultsArea').innerHTML = html;
    byId('checkBalanceBtn').style.display='';
    byId('forecastBtn').style.display='';
    await knowledgeBase.pushHistory({ type:'search', title: `${API_CONFIG[provider].name}: ${query.slice(0,48)}`, payload: html }); await refreshHistory();
  }
  byId('statusText').textContent='BATHALA INTELLIGENCE: AI search completed';
}

async function performLocalFileSearch(){
  const q=byId('searchInput').value.trim(); if(!q) return toast('Enter a search query','warn');
  setSearchVisible(); byId('statusText').textContent='BATHALA INTELLIGENCE: Searching local file database‚Ä¶';
  const docs=await knowledgeBase.searchDocuments(q);
  if(docs.length===0){
    byId('resultsArea').innerHTML = `<div class='card'>‚ùå No files match \"${q}\"</div>`;
  } else {
    let ctx='Found '+docs.length+" file(s):\n\n";
    docs.forEach((d,i)=>{ ctx+=`üìÑ ${i+1}. ${d.filename} (${(d.size/(1024*1024)).toFixed(2)}MB)\n`; });
    const body = `<div class='response-card'><div class='response-header'><div class='provider-badge'>üìÅ File Database</div><div>File Search</div></div><div class='response-content'>${highlight(ctx,q)}</div></div>`;
    byId('resultsArea').innerHTML = body;
    await knowledgeBase.pushHistory({ type:'search', title:`Files: ${q.slice(0,48)}`, payload: body }); await refreshHistory();
  }
}

async function performLocalContentSearch(){
  const q=byId('searchInput').value.trim(); if(!q) return toast('Enter a search query','warn');
  setSearchVisible(); byId('statusText').textContent='BATHALA INTELLIGENCE: Searching local content (OCR)‚Ä¶';
  const docs=await knowledgeBase.searchDocuments(q);
  if(docs.length===0){
    byId('resultsArea').innerHTML = `<div class='card'>‚ùå No content matches \"${q}\"</div>`;
  } else {
    let html='';
    docs.forEach((d)=>{
      const prev = highlight(d.content.slice(0,1500), q);
      html+=`<div class='response-card'><div class='response-header'><div class='provider-badge'>üìñ ${d.filename}</div><div>${(d.size/(1024*1024)).toFixed(2)}MB</div></div><div class='response-content'>${prev}${d.content.length>1500?'‚Ä¶':''}</div></div>`;
    });
    byId('resultsArea').innerHTML = html;
    await knowledgeBase.pushHistory({ type:'search', title:`Content: ${q.slice(0,48)}`, payload: html }); await refreshHistory();
  }
}

async function performCombinedSearch(){
  const q=byId('searchInput').value.trim();
  const provider=byId('aiProvider').value;
  const persona=byId('personaSelect').value;
  if(!q) return toast('Enter a search query','warn');
  const hasKeys=['deepseek','openai','grok'].some(p=> byId(p+'Key')?.value);
  if(!hasKeys) return toast('Configure at least one AI key','warn');
  setSearchVisible(); byId('statusText').textContent='BATHALA INTELLIGENCE: Executing combined AI search‚Ä¶';

  if(provider==='compare'){
    const out=[];
    for(const prov of ['deepseek','openai','grok']){
      const key=byId(prov+'Key')?.value;
      if(!key){ out.push({provider:prov, success:false, error:'API key not configured', responseTime:0}); continue;}
      const r=await combinedAIQuery(prov, q, key, persona); out.push({provider:prov, ...r});
    }
    const html = renderCompareResults(q, out);
    byId('resultsArea').innerHTML = html;
    
    // Only show check balance if we have actual AI responses (not just no-match messages)
    const hasActualResults = out.some(r => r.success && !r.noMatch);
    byId('checkBalanceBtn').style.display = hasActualResults ? '' : 'none';
    byId('forecastBtn').style.display = hasActualResults ? '' : 'none';
    
    await knowledgeBase.pushHistory({ type:'search', title:`Combined: ${q.slice(0,48)}`, payload: html }); 
    await refreshHistory();
  } else {
    const key=byId(provider+'Key')?.value; if(!key){ return toast(`Configure ${API_CONFIG[provider].name} key`,'warn'); }
    const r=await combinedAIQuery(provider, q, key, persona);
    const body = r.success? r.content : `<div style='color:var(--error)'>‚ùå ${r.error}</div>`;
    const noMatchStyle = r.noMatch ? 'style="border-color: var(--warn); background: rgba(255,165,0,.05);"' : '';
    const html = `<div class="response-card" ${noMatchStyle}>
      <div class="response-header">
        <div class="provider-badge">${API_CONFIG[provider].name}</div>
        <div class="response-time">${r.responseTime}ms${r.cached?' ¬∑ cached':''}</div>
      </div>
      <div class="response-content">${body}</div>
      ${!r.noMatch ? `
      <div style="margin-top:12px;padding:10px;background:rgba(255,165,0,.08);border:1px solid var(--warn);border-radius:8px">
        <strong>Search Type:</strong> Combined (Local DB + AI) ‚Ä¢ <strong>Mode:</strong> ${persona}
      </div>
      ` : ''}
    </div>`;
    byId('resultsArea').innerHTML = html;
    byId('checkBalanceBtn').style.display = r.noMatch ? 'none' : '';
    byId('forecastBtn').style.display = r.noMatch ? 'none' : '';
    await knowledgeBase.pushHistory({ type:'search', title:`${API_CONFIG[provider].name}: ${q.slice(0,48)}`, payload: html }); 
    await refreshHistory();
  }
  byId('statusText').textContent='BATHALA INTELLIGENCE: Combined search completed';
}

// Bathala Agents - Search connected databases
async function performAgentsSearch() {
  const q = byId('searchInput').value.trim();
  const provider = byId('aiProvider').value;
  const persona = byId('personaSelect').value;
  
  if (!q) return toast('Enter a search query', 'warn');
  
  const hasKeys = ['deepseek', 'openai', 'grok'].some(p => byId(p + 'Key')?.value);
  if (!hasKeys) return toast('Configure at least one AI key', 'warn');
  
  setSearchVisible(); 
  byId('statusText').textContent = 'BATHALA INTELLIGENCE: Querying connected databases‚Ä¶';

  if (provider === 'compare') {
    const out = [];
    for (const prov of ['deepseek', 'openai', 'grok']) {
      const key = byId(prov + 'Key')?.value;
      if (!key) { 
        out.push({ provider: prov, success: false, error: 'API key not configured', responseTime: 0 }); 
        continue;
      }
      const r = await databaseAIQuery(prov, q, key, persona); 
      out.push({ provider: prov, ...r });
    }
    const html = renderCompareResults(q, out);
    byId('resultsArea').innerHTML = html;
    
    // Only show check balance if we have actual AI responses (not just no-match messages)
    const hasActualResults = out.some(r => r.success && !r.noMatch);
    byId('checkBalanceBtn').style.display = hasActualResults ? '' : 'none';
    byId('forecastBtn').style.display = hasActualResults ? '' : 'none';
    
    await knowledgeBase.pushHistory({ type: 'search', title: `Agents: ${q.slice(0, 48)}`, payload: html }); 
    await refreshHistory();
  } else {
    const key = byId(provider + 'Key')?.value; 
    if (!key) { 
      return toast(`Configure ${API_CONFIG[provider].name} key`, 'warn'); 
    }
    const r = await databaseAIQuery(provider, q, key, persona);
    const body = r.success ? r.content : `<div style='color:var(--error)'>‚ùå ${r.error}</div>`;
    const noMatchStyle = r.noMatch ? 'style="border-color: var(--warn); background: rgba(255,165,0,.05);"' : '';
    const html = `<div class="response-card" ${noMatchStyle}>
      <div class="response-header">
        <div class="provider-badge">${API_CONFIG[provider].name}</div>
        <div class="response-time">${r.responseTime}ms${r.cached ? ' ¬∑ cached' : ''}</div>
      </div>
      <div class="response-content">${body}</div>
      ${!r.noMatch ? `
      <div style="margin-top:12px;padding:10px;background:rgba(255,165,0,.08);border:1px solid var(--warn);border-radius:8px">
        <strong>Search Type:</strong> Database Agents ‚Ä¢ <strong>Mode:</strong> ${persona} ‚Ä¢ <strong>Source:</strong> Connected Databases
      </div>
      ` : ''}
    </div>`;
    byId('resultsArea').innerHTML = html;
    byId('checkBalanceBtn').style.display = r.noMatch ? 'none' : '';
    byId('forecastBtn').style.display = r.noMatch ? 'none' : '';
    await knowledgeBase.pushHistory({ type: 'search', title: `${API_CONFIG[provider].name} Agents: ${q.slice(0, 48)}`, payload: html }); 
    await refreshHistory();
  }
  byId('statusText').textContent = 'BATHALA INTELLIGENCE: Database query completed';
}

// Super Mode - Integrated search (Library + Database + AI Engines)
async function performSuperModeSearch() {
  const q = byId('searchInput').value.trim();
  const provider = byId('aiProvider').value;
  const persona = byId('personaSelect').value;
  
  if (!q) return toast('Enter a search query', 'warn');
  
  const hasKeys = ['deepseek', 'openai', 'grok'].some(p => byId(p + 'Key')?.value);
  if (!hasKeys) return toast('Configure at least one AI key', 'warn');
  
  setSearchVisible(); 
  byId('statusText').textContent = 'BATHALA INTELLIGENCE: Activating SUPER MODE (Library + Database + AI Engines)‚Ä¶';

  if (provider === 'compare') {
    const out = [];
    for (const prov of ['deepseek', 'openai', 'grok']) {
      const key = byId(prov + 'Key')?.value;
      if (!key) { 
        out.push({ provider: prov, success: false, error: 'API key not configured', responseTime: 0 }); 
        continue;
      }
      const r = await superModeAIQuery(prov, q, key, persona); 
      out.push({ provider: prov, ...r });
    }
    const html = renderCompareResults(q, out);
    byId('resultsArea').innerHTML = html;
    
    // Only show check balance if we have actual AI responses (not just no-match messages)
    const hasActualResults = out.some(r => r.success && !r.noMatch);
    byId('checkBalanceBtn').style.display = hasActualResults ? '' : 'none';
    byId('forecastBtn').style.display = hasActualResults ? '' : 'none';
    
    await knowledgeBase.pushHistory({ type: 'search', title: `SUPER MODE: ${q.slice(0, 48)}`, payload: html }); 
    await refreshHistory();
  } else {
    const key = byId(provider + 'Key')?.value; 
    if (!key) { 
      return toast(`Configure ${API_CONFIG[provider].name} key`, 'warn'); 
    }
    const r = await superModeAIQuery(provider, q, key, persona);
    const body = r.success ? r.content : `<div style='color:var(--error)'>‚ùå ${r.error}</div>`;
    const noMatchStyle = r.noMatch ? 'style="border-color: var(--warn); background: rgba(255,165,0,.05);"' : '';
    const html = `<div class="response-card" ${noMatchStyle}>
      <div class="response-header">
        <div class="provider-badge">${API_CONFIG[provider].name}</div>
        <div class="response-time">${r.responseTime}ms${r.cached ? ' ¬∑ cached' : ''}</div>
      </div>
      <div class="response-content">${body}</div>
      ${!r.noMatch ? `
      <div style="margin-top:12px;padding:10px;background:rgba(255,0,255,.08);border:1px solid #ff00ff;border-radius:8px">
        <strong>Search Type:</strong> SUPER MODE ‚Ä¢ <strong>Mode:</strong> ${persona} ‚Ä¢ <strong>Sources:</strong> Library + Databases + AI Engines
      </div>
      ` : ''}
    </div>`;
    byId('resultsArea').innerHTML = html;
    byId('checkBalanceBtn').style.display = r.noMatch ? 'none' : '';
    byId('forecastBtn').style.display = r.noMatch ? 'none' : '';
    await knowledgeBase.pushHistory({ type: 'search', title: `SUPER MODE ${API_CONFIG[provider].name}: ${q.slice(0, 48)}`, payload: html }); 
    await refreshHistory();
  }
  byId('statusText').textContent = 'BATHALA INTELLIGENCE: SUPER MODE analysis completed';
}

// Forecast Analysis - FIXED FUNCTION NAME
async function performForecastAnalysis() {
  const q = byId('searchInput').value.trim();
  const provider = byId('aiProvider').value;
  const persona = byId('personaSelect').value;
  
  if (!q) return toast('Enter a search query', 'warn');
  
  const hasKeys = ['deepseek', 'openai', 'grok'].some(p => byId(p + 'Key')?.value);
  if (!hasKeys) return toast('Configure at least one AI key', 'warn');
  
  setSearchVisible(); 
  byId('statusText').textContent = 'BATHALA INTELLIGENCE: Generating 1-5 year forecast‚Ä¶';

  if (provider === 'compare') {
    const out = [];
    for (const prov of ['deepseek', 'openai', 'grok']) {
      const key = byId(prov + 'Key')?.value;
      if (!key) { 
        out.push({ provider: prov, success: false, error: 'API key not configured', responseTime: 0 }); 
        continue;
      }
      const r = await forecastAIQuery(prov, q, key, persona); 
      out.push({ provider: prov, ...r });
    }
    const html = renderCompareResults(`Forecast: ${q}`, out);
    byId('resultsArea').innerHTML = html;
    
    await knowledgeBase.pushHistory({ type: 'search', title: `FORECAST: ${q.slice(0, 48)}`, payload: html }); 
    await refreshHistory();
  } else {
    const key = byId(provider + 'Key')?.value; 
    if (!key) { 
      return toast(`Configure ${API_CONFIG[provider].name} key`, 'warn'); 
    }
    const r = await forecastAIQuery(provider, q, key, persona);
    const body = r.success ? r.content : `<div style='color:var(--error)'>‚ùå ${r.error}</div>`;
    const noMatchStyle = r.noMatch ? 'style="border-color: var(--warn); background: rgba(255,165,0,.05);"' : '';
    const html = `<div class="response-card" ${noMatchStyle}>
      <div class="response-header">
        <div class="provider-badge">${API_CONFIG[provider].name}</div>
        <div class="response-time">${r.responseTime}ms${r.cached ? ' ¬∑ cached' : ''}</div>
      </div>
      <div class="response-content">${body}</div>
      ${!r.noMatch ? `
      <div style="margin-top:12px;padding:10px;background:rgba(0,191,255,.08);border:1px solid #00bfff;border-radius:8px">
        <strong>Analysis Type:</strong> FORECAST ‚Ä¢ <strong>Timeframe:</strong> 1-5 Years ‚Ä¢ <strong>Mode:</strong> ${persona}
      </div>
      ` : ''}
    </div>`;
    byId('resultsArea').innerHTML = html;
    await knowledgeBase.pushHistory({ type: 'search', title: `FORECAST ${API_CONFIG[provider].name}: ${q.slice(0, 48)}`, payload: html }); 
    await refreshHistory();
  }
  byId('statusText').textContent = 'BATHALA INTELLIGENCE: Forecast analysis completed';
}

// ===== Consensus Synthesis + Visualization
function jaccard(a,b){
  const A=new Set((a||'').split(/\W+/).map(x=>x.toLowerCase()).filter(Boolean));
  const B=new Set((b||'').split(/\W+/).map(x=>x.toLowerCase()).filter(Boolean));
  const inter=[...A].filter(x=>B.has(x)).length;
  const uni=new Set([...A,...B]).size;
  return uni? inter/uni : 0;
}
let consensusChart;
function drawConsensusChart(metrics){
  const ctx=byId('consensusChart');
  const labels=['Agreement','Depth','Speed'];
  const data={ labels, datasets:[
    { label:'Agent 1', data:metrics.deepseek, fill:true },
    { label:'Agent 2', data:metrics.openai, fill:true },
    { label:'Agent 3', data:metrics.grok, fill:true }
  ]};
  if(consensusChart) consensusChart.destroy();
  consensusChart = new Chart(ctx,{
    type:'radar', data,
    options:{ plugins:{legend:{labels:{color:'#fff'}}},
      scales:{ r:{ angleLines:{color:'rgba(255,255,255,.2)'},
                   grid:{color:'rgba(255,255,255,.2)'},
                   pointLabels:{color:'#fff'}, suggestedMin:0, suggestedMax:1 } }
    }
  });
}

// Helper function to safely convert values to strings
function safeStringify(value, fallback = 'Not available') {
  if (typeof value === 'string') return value;
  if (typeof value === 'object' && value !== null) {
    try {
      return JSON.stringify(value, null, 2);
    } catch (e) {
      return String(value) || fallback;
    }
  }
  return String(value || fallback);
}

async function checkBalance(){
  const cards=$$('.response-card');
  if(cards.length===0){ return toast('No responses to analyze','warn'); }
  const query=byId('searchInput').value.trim();
  const provider = getArbitrationProvider();
  if(!provider) return toast('Configure at least one AI key','warn');
  const apiKey=byId(provider+'Key').value;

  let prompt=`You are Bathala Arbitration Intelligence ‚Äî a meta-governance AI. Perform CHECK & BALANCE and produce a CONSENSUS RESPONSE. Responsibilities: 1) Summarize agreements and disagreements. 2) Merge insights into one factual answer. 3) Credit agents. Output JSON with keys consensus_summary, synthesized_response, credits.
USER QUERY:
${query}
AGENT RESPONSES:
`;
  cards.forEach((c)=>{
    prompt+=`---
Agent: ${c.querySelector('.provider-badge')?.textContent}
Response:
${c.querySelector('.response-content')?.textContent.trim()}
`;
  });
  prompt+=`---
Return ONLY JSON object.`;

  byId('statusText').textContent='BATHALA INTELLIGENCE: Synthesizing consensus‚Ä¶';
  const result = await queryAI(provider, prompt, apiKey, byId('personaSelect').value);
  if(!result.success){ toast('Consensus failed: '+result.error,'error'); return; }

  let parsed;
  try{
    // Improved JSON parsing - try multiple approaches
    let jsonStr = result.content.trim();
    
    // Remove markdown code blocks if present
    jsonStr = jsonStr.replace(/```json\s*/g, '').replace(/```\s*/g, '');
    
    // Try to parse directly first
    parsed = JSON.parse(jsonStr);
  } catch(e) {
    try {
      // If direct parsing fails, try to extract JSON from the text
      const jsonMatch = result.content.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        parsed = JSON.parse(jsonMatch[0]);
      } else {
        // If all else fails, create a fallback response
        const agents = [...cards].map(c => c.querySelector('.provider-badge')?.textContent).filter(Boolean);
        parsed = {
          consensus_summary: "Unable to parse structured consensus. Here's the raw response: " + result.content.substring(0, 500),
          synthesized_response: result.content,
          credits: agents.join(', ')
        };
      }
    } catch(parseError) {
      // Final fallback
      const agents = [...cards].map(c => c.querySelector('.provider-badge')?.textContent).filter(Boolean);
      parsed = {
        consensus_summary: "Consensus analysis completed successfully",
        synthesized_response: result.content,
        credits: agents.join(', ') || 'AI Agent 1, AI Agent 2, AI Agent 3'
      };
    }
  }

  // Ensure we have the required fields as strings using safeStringify
  parsed.consensus_summary = safeStringify(parsed.consensus_summary, 'No consensus summary available');
  parsed.synthesized_response = safeStringify(parsed.synthesized_response, 'No synthesized response available');
  parsed.credits = safeStringify(parsed.credits, 'AI Agent 1, AI Agent 2, AI Agent 3');

  const block = `<div class="consensus-block">
    <h3>‚öñÔ∏è BATHALA INTELLIGENCE ‚Äî CONSENSUS SYNTHESIS</h3>
    <div class="response-header"><div class="provider-badge">üß† Unified Bathala Consensus</div><div>AI-Synthesized</div></div>
    <div class="response-content">
      <strong>Consensus Summary:</strong><br>${parsed.consensus_summary}<br><br>
      <strong>Final Synthesized Response:</strong><br>${parsed.synthesized_response}<br><br>
      <strong>Agent Contributions:</strong><br>${parsed.credits}
    </div>
    <div style="margin-top:15px;padding:12px;background:rgba(155,89,182,.1);border:1px solid var(--violet);border-radius:6px">
      <strong>Evaluator:</strong> Bathala<br><strong>Mode:</strong> Consensus Synthesis (Collective Intelligence)
    </div>
  </div>`;
  const area=byId('consensusBlock'); area.style.display='block'; area.innerHTML = block;

  const responses=[...cards].map(c=>({
    prov: c.querySelector('.provider-badge')?.textContent||'',
    content: c.querySelector('.response-content')?.textContent||'',
    ms: parseInt(c.querySelector('.response-time')?.textContent||'0') || 0
  }));
  const texts={}; const speeds={};
  responses.forEach(r=>{
    if(r.prov.includes('Agent 1')){texts.deepseek=r.content; speeds.deepseek=r.ms;}
    if(r.prov.includes('Agent 2')){texts.openai=r.content; speeds.openai=r.ms;}
    if(r.prov.includes('Agent 3')){texts.grok=r.content; speeds.grok=r.ms;}
  });
  const base = texts.openai||texts.deepseek||texts.grok||'';
  const metrics={
    deepseek:[ jaccard(base,texts.deepseek||''), Math.tanh((texts.deepseek||'').length/1200), Math.tanh(800/(speeds.deepseek||800)) ],
    openai:[ jaccard(base,texts.openai||''), Math.tanh((texts.openai||'').length/1200), Math.tanh(800/(speeds.openai||800)) ],
    grok:[ jaccard(base,texts.grok||''), Math.tanh((texts.grok||'').length/1200), Math.tanh(800/(speeds.grok||800)) ]
  };
  drawConsensusChart(metrics);

  await knowledgeBase.pushHistory({ type:'consensus', title:`Consensus: ${query.slice(0,48)}`, payload: area.innerHTML }); await refreshHistory();
  toast('Consensus synthesized','success');
}

// ===== History renderers
async function refreshHistory(){
  const s=byId('searchHistory'); const c=byId('consensusHistory');
  if(!s||!c) return;
  const searches=await knowledgeBase.listHistory('search',8);
  const cons=await knowledgeBase.listHistory('consensus',8);
  s.innerHTML = searches.map(h=>`<button class='history-item' onclick='restoreHistory(${JSON.stringify(h.id)})'><span class='badge'>SEARCH</span><span>${h.title}</span></button>`).join('');
  c.innerHTML = cons.map(h=>`<button class='history-item' onclick='restoreHistory(${JSON.stringify(h.id)})'><span class='badge' style='border-color:var(--violet);color:var(--violet)'>CONSENSUS</span><span>${h.title}</span></button>`).join('');
}
async function restoreHistory(id){
  await knowledgeBase.ready;
  const tx=knowledgeBase.db.transaction(['history'],'readonly'); const st=tx.objectStore('history');
  const req=st.get(id);
  req.onsuccess=()=>{ const rec=req.result; if(rec){ setSearchVisible(); if(rec.type==='search'){ byId('resultsArea').innerHTML = rec.payload; } else { byId('consensusBlock').style.display='block'; byId('consensusBlock').innerHTML = rec.payload; } } };
}

// ===== Events
function bindEvents(){
  const fileInput = byId('fileInput');
  if(fileInput){
    fileInput.addEventListener('change', async (e)=>{
      const files=e.target.files;
      if(files.length>0){
        byId('statusText').textContent=`Processing ${files.length} file(s)‚Ä¶`;
        await fileProcessor.processFiles(files);
        byId('statusText').textContent=`${files.length} file(s) processed`;
        e.target.value='';
      }
    });
  }

  // Database connection events
  byId('addConnectionBtn').addEventListener('click', showAddConnectionModal);

  byId('searchBtn')?.addEventListener('click', performAISearch);
  byId('localFileBtn')?.addEventListener('click', performLocalFileSearch);
  byId('localContentBtn')?.addEventListener('click', performLocalContentSearch);
  byId('combinedBtn')?.addEventListener('click', performCombinedSearch);
  byId('agentsBtn')?.addEventListener('click', performAgentsSearch);
  byId('superModeBtn')?.addEventListener('click', performSuperModeSearch);
  byId('checkBalanceBtn')?.addEventListener('click', checkBalance);
  byId('forecastBtn')?.addEventListener('click', performForecastAnalysis); // FIXED: Changed from performForecast to performForecastAnalysis

  byId('connectAgentsBtn')?.addEventListener('click', async ()=>{
    byId('statusText').textContent='Connecting AI Agents‚Ä¶';
    const r=await Promise.all([testApiConnection('deepseek'), testApiConnection('openai'), testApiConnection('grok')]);
    const n=r.filter(Boolean).length;
    if(n>0){
      byId('globalStatus').className='status-dot connected';
      toast(`${n}/3 agents connected`,'success');
      byId('statusText').textContent=`${n}/3 AI Agents connected - Ready`;
    } else {
      toast('No agents connected','warn');
      byId('statusText').textContent='No AI Agents connected';
    }
  });
  byId('disconnectAgentsBtn')?.addEventListener('click', ()=>{ disconnectAgents(); toast('Agents disconnected','warn'); });
  byId('saveConfigBtn')?.addEventListener('click', ()=>{
    ['deepseek','openai','grok'].forEach(p=>{
      const k=byId(p+'Key')?.value;
      if(k){ localStorage.setItem(p+'_api_key',k); updateApiStatus(p,'saved'); }
    });
    toast('Configuration saved','success');
  });
}

// ===== Init
(async function init(){
  await knowledgeBase.ready; // DB ready
  loadApiKeys();
  await updateDocumentsList();
  await refreshHistory();
  renderDatabaseConnections();
  bindEvents();
})();
</script>
</body>
</html>
