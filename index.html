<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Bathala Intelligence ‚Äî v6.0</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
  <!-- Chart.js for Consensus Visualization -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <!-- PDF.js, Tesseract, Mammoth, SheetJS -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
  <script src="https://unpkg.com/tesseract.js@v4.0.0/dist/tesseract.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <!-- SQL.js for SQLite support -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.js"></script>
  <style>
    /* ALL YOUR CSS REMAINS EXACTLY THE SAME */
    :root {
      --bg-0: #07090c;
      --bg-1: #0a0f17;
      --bg-2: #0d1420;
      --neon: #00ff88;
      --neon-2: #00cc6a;
      --neon-3: #00994d;
      --muted: #a0aec0;
      --error: #ff4444;
      --warn: #ffa500;
      --violet: #9b59b6;
      --card: #0a0f1a;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    html, body { height: 100%; font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu; }

    body {
      background:
        radial-gradient(1200px 600px at 20% -10%, rgba(0,255,136,.08), transparent 60%),
        radial-gradient(800px 500px at 120% 10%, rgba(155,89,182,.08), transparent 60%),
        linear-gradient(135deg, var(--bg-0), var(--bg-1), var(--bg-2));
      color: #fff;
      line-height: 1.5;
    }

    /* Layout */
    .app { display: flex; min-height: 100vh; }

    .sidebar {
      width: 300px;
      background: rgba(7,9,12,.8);
      backdrop-filter: blur(8px);
      border-right: 1px solid rgba(0,255,136,.35);
      padding: 18px;
      position: sticky;
      top: 0;
      align-self: flex-start;
      height: 100vh;
      overflow: auto;
    }

    .brand { display: flex; align-items: center; gap: 10px; margin-bottom: 18px; }

    .brand .logo {
      width: 36px;
      height: 36px;
      border-radius: 10px;
      background: radial-gradient(circle at 30% 30%, var(--neon), #0b2a1e 70%);
      box-shadow: 0 0 18px rgba(0,255,136,.5);
    }

    .brand h1 {
      font-size: 1.1rem;
      letter-spacing: .12em;
      font-weight: 900;
      background: linear-gradient(45deg, var(--neon), var(--neon-2), var(--neon-3));
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      text-transform: uppercase;
    }

    .menu-group { margin: 12px 0; }

    .menu-title {
      font-weight: 900;
      font-size: .8rem;
      letter-spacing: .1em;
      color: var(--muted);
      margin: 8px 4px;
    }

    .nav { display: flex; flex-direction: column; gap: 8px; margin-top: 6px; }

    .nav button {
      all: unset;
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 12px;
      border: 1px solid rgba(0,255,136,.35);
      border-radius: 10px;
      cursor: pointer;
      font-weight: 700;
      transition: all 0.2s ease;
    }

    .nav button:hover { background: rgba(0,255,136,.05); }

    .nav button.active {
      background: linear-gradient(135deg, rgba(0,255,136,.15), rgba(0,255,136,.05));
      box-shadow: 0 0 20px rgba(0,255,136,.15);
    }

    .nav .icon { width: 24px; text-align: center; }

    .history { margin-top: 14px; }

    .history h4 { margin: 6px 4px; color: var(--muted); font-size: .85rem; }

    .history-list { display: flex; flex-direction: column; gap: 6px; }

    .history-item {
      all: unset;
      cursor: pointer;
      display: flex;
      gap: 8px;
      align-items: flex-start;
      border: 1px solid rgba(255,255,255,.1);
      border-radius: 8px;
      padding: 8px;
      transition: border-color 0.2s ease;
    }

    .history-item:hover { border-color: rgba(0,255,136,.35); }

    .badge {
      font-size: .72rem;
      padding: 2px 6px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,.2);
      white-space: nowrap;
    }

    .content { flex: 1; max-width: 1400px; margin: 18px auto; padding: 18px; }

    .panel { display: none; }

    .panel.active { display: block; }

    /* Header card */
    .header-card {
      background: rgba(7,9,12,.98);
      border: 1px solid var(--neon);
      border-radius: 16px;
      padding: 20px;
      box-shadow: 0 0 40px rgba(0,255,136,.08);
    }

    .header-title {
      font-size: 1.9rem;
      font-weight: 900;
      margin: 0 0 6px;
      text-shadow: 0 0 12px rgba(0,255,136,.35);
    }

    .tagline { color: var(--muted); }

    /* Grid */
    .grid { display: grid; gap: 16px; grid-template-columns: repeat(12, 1fr); }

    .col-12 { grid-column: span 12; }

    .col-6 { grid-column: span 6; }

    .col-4 { grid-column: span 4; }

    .card {
      background: var(--card);
      border: 1px solid var(--neon);
      border-radius: 12px;
      padding: 16px;
    }

    /* Inputs */
    input, select, textarea {
      width: 100%;
      padding: 12px;
      border: 1px solid var(--neon);
      border-radius: 8px;
      background: rgba(0,0,0,.45);
      color: #fff;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    textarea {
      min-height: 80px;
      resize: vertical;
    }

    label {
      font-size: .8rem;
      color: var(--neon);
      margin-bottom: 6px;
      display: block;
    }

    /* Buttons */
    .btn {
      border: none;
      border-radius: 10px;
      padding: 12px 16px;
      font-weight: 800;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      transition: transform .15s ease, box-shadow .25s ease;
    }

    .btn:disabled { opacity: .6; cursor: not-allowed; }

    .btn-primary { background: linear-gradient(45deg, var(--neon), var(--neon-2)); color: #000; }

    .btn-danger { background: linear-gradient(45deg, #ff6b6b, #ff4444); color: #fff; }

    .btn-info { background: linear-gradient(45deg, #4facfe, #00f2fe); color: #000; }

    .btn-success { background: linear-gradient(45deg, #00cc6a, #00ff88); color: #000; }

    .btn-warning { background: linear-gradient(45deg, #ffa500, #ffb732); color: #000; }

    .btn-super { background: linear-gradient(45deg, #ff00ff, #ff0080); color: #fff; }

    .btn-forecast { background: linear-gradient(45deg, #00bfff, #0066ff); color: #fff; }

    .btn:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 10px 25px rgba(0,255,136,.25);
    }

    .status-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #ff4444;
    }

    .status-dot.connected {
      background: var(--neon);
      box-shadow: 0 0 0 0 rgba(0,255,136,.8);
      animation: pulse 1.5s infinite;
    }

    .status-dot.connecting {
      background: var(--warn);
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
      to { box-shadow: 0 0 0 14px rgba(0,255,136,0); }
    }

    /* Toasts */
    .toast-stack {
      position: fixed;
      right: 18px;
      bottom: 18px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 9999;
    }

    .toast {
      min-width: 260px;
      max-width: 360px;
      background: rgba(0,0,0,.85);
      border: 1px solid rgba(255,255,255,.12);
      backdrop-filter: blur(8px);
      color: #fff;
      padding: 12px 14px;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      display: flex;
      gap: 10px;
      align-items: flex-start;
    }

    .toast .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      flex-shrink: 0;
      margin-top: 4px;
    }

    .toast.success { border-color: rgba(0,255,136,.45); }

    .toast.error { border-color: rgba(255,68,68,.45); }

    .toast.warn { border-color: rgba(255,165,0,.45); }

    /* Loaders */
    .loading-wrap { display: none; align-items: center; gap: 10px; }

    .loading-wrap.active { display: flex; }

    .spinner3d {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      border: 3px solid rgba(0,255,136,.15);
      border-top-color: var(--neon);
      animation: spin 1s linear infinite;
      box-shadow: 0 0 20px rgba(0,255,136,.35) inset;
    }

    @keyframes spin { to { transform: rotate(360deg); } }

    /* Results */
    .response-grid { display: grid; gap: 16px; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); }

    .response-card {
      background: rgba(0,0,0,.3);
      border: 1px solid var(--neon);
      border-radius: 10px;
      padding: 16px;
    }

    .response-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      border-bottom: 1px solid rgba(0,255,136,.25);
      padding-bottom: 8px;
    }

    .actions { display: flex; gap: 8px; flex-wrap: wrap; }

    /* Consensus */
    .consensus-block {
      background: rgba(155,89,182,.10);
      border: 2px solid var(--violet);
      border-radius: 12px;
      padding: 16px;
      margin-top: 16px;
    }

    /* Database Connections */
    .database-connections {
      display: grid;
      gap: 16px;
      grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
      margin-bottom: 20px;
    }

    .db-connection-card {
      background: var(--card);
      border: 1px solid var(--neon);
      border-radius: 12px;
      padding: 16px;
      position: relative;
    }

    .db-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 1px solid rgba(0,255,136,.25);
    }

    .db-icon {
      font-size: 1.5rem;
      margin-right: 8px;
    }

    .db-status {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 0.8rem;
    }

    .connection-form {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .form-row {
      display: flex;
      gap: 10px;
    }

    .form-row > * {
      flex: 1;
    }

    .add-connection-btn {
      background: rgba(0,255,136,.1);
      border: 2px dashed var(--neon);
      color: var(--neon);
      padding: 20px;
      text-align: center;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .add-connection-btn:hover {
      background: rgba(0,255,136,.2);
      transform: translateY(-2px);
    }

    /* Database Type Badges */
    .db-type-badge {
      padding: 4px 8px;
      border-radius: 6px;
      font-size: 0.7rem;
      font-weight: 600;
      text-transform: uppercase;
    }

    .db-type-file { background: rgba(0,255,136,.2); border: 1px solid var(--neon); }
    .db-type-server { background: rgba(155,89,182,.2); border: 1px solid var(--violet); }
    .db-type-backend { background: rgba(255,165,0,.2); border: 1px solid var(--warn); }

    /* Search Navigation */
    .search-navigation {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      margin-top: 12px;
      padding: 10px;
      background: rgba(0,0,0,.3);
      border-radius: 8px;
      border: 1px solid rgba(0,255,136,.25);
    }

    .search-navigation button {
      background: rgba(0,255,136,.1);
      border: 1px solid var(--neon);
      color: var(--neon);
      border-radius: 6px;
      padding: 6px 12px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .search-navigation button:hover:not(:disabled) {
      background: rgba(0,255,136,.2);
      transform: translateY(-1px);
    }

    .search-navigation button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .match-info {
      font-size: 0.9rem;
      color: var(--muted);
    }

    .highlight-match {
      background: rgba(255,255,0,0.3) !important;
      border: 1px solid yellow;
      padding: 2px 4px;
      border-radius: 3px;
    }

    .page-indicator {
      background: rgba(155,89,182,.2);
      border: 1px solid var(--violet);
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 0.8rem;
    }

    /* Footer */
    footer { margin: 24px 0 8px; text-align: center; color: var(--muted); }

    /* Responsive */
    @media (max-width: 1024px) {
      .sidebar { width: 90px; padding: 12px; }
      .brand h1 { display: none; }
      .menu-title { display: none; }
      .nav button span.label { display: none; }
    }

    @media (max-width: 640px) {
      .content { padding: 12px; }
      .col-6 { grid-column: span 12; }
      .col-4 { grid-column: span 12; }
      .btn { padding: 10px 12px; font-size: 0.9rem; }
      .database-connections { grid-template-columns: 1fr; }
      .form-row { flex-direction: column; }
    }
  </style>
</head>
<body>
<div class="app">
  <!-- Sidebar Navigation -->
  <aside class="sidebar">
    <div class="brand">
      <div class="logo"></div>
      <h1>Bathala Intelligence</h1>
    </div>

    <div class="menu-group">
      <div class="menu-title">MAIN</div>
      <div class="nav">
        <button data-panel="dashboard" class="active">
          <span class="icon">üè†</span>
          <span class="label">Dashboard</span>
        </button>
        <button data-panel="storage">
          <span class="icon">üìö</span>
          <span class="label">Database Storage</span>
        </button>
        <button data-panel="agents">
          <span class="icon">üîë</span>
          <span class="label">Agents Configuration</span>
        </button>
      </div>
    </div>

    <div class="menu-group history">
      <h4>Recent Searches</h4>
      <div id="searchHistory" class="history-list"></div>
      <h4 style="margin-top:10px">Recent Consensus</h4>
      <div id="consensusHistory" class="history-list"></div>
    </div>
  </aside>

  <main class="content">
    <!-- Header -->
    <section class="header-card">
      <div class="header-title">üõ°Ô∏è BATHALA INTELLIGENCE</div>
      <div class="tagline">An AI-Driven Governance Platform</div>
    </section>

    <!-- DASHBOARD: Search + Results + Consensus -->
    <section id="panel-dashboard" class="panel active">
      <div class="card">
        <h3>üîç INTELLIGENCE SEARCH</h3>
        <div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:10px">
          <input id="searchInput" placeholder="Enter your search query‚Ä¶" />
          <select id="aiProvider">
            <option value="compare">Compare All AI Agents</option>
            <option value="deepseek">AI Agent 1</option>
            <option value="openai">AI Agent 2</option>
            <option value="grok">AI Agent 3</option>
          </select>
          <select id="personaSelect" title="Agent Personality Mode">
            <option value="analyst">üßÆ Analyst</option>
            <option value="ethicist">üß≠ Ethicist</option>
            <option value="strategist" selected>üéØ Strategist</option>
            <option value="creative">üé® Creative</option>
          </select>
          <button class="btn btn-primary" id="searchBtn">üöÄ AI SEARCH</button>
          <button class="btn btn-info" id="localFileBtn">üìÅ FIND FILE</button>
          <button class="btn btn-info" id="localContentBtn">üîç FIND CONTENT</button>
          <button class="btn btn-info" id="combinedBtn">üîÑ BATHALA MODE</button>
          <button class="btn btn-warning" id="agentsBtn">ü§ñ BATHALA AGENTS</button>
          <!-- NEW: SUPER MODE BUTTON -->
          <button class="btn btn-super" id="superModeBtn">üåü SUPER MODE</button>
        </div>
      </div>

      <div class="card" id="resultsSection" style="display:none;margin-top:12px">
        <div class="response-header">
          <h3>üìä SEARCH RESULTS</h3>
          <div id="resultsInfo" style="color:var(--neon)">Ready for analysis</div>
        </div>
        <div id="resultsArea"></div>
        
        <!-- Search Navigation -->
        <div class="search-navigation" id="searchNavigation" style="display:none">
          <button id="prevMatchBtn" disabled>‚óÄ Previous</button>
          <div class="match-info" id="matchInfo">Match 1 of 1</div>
          <button id="nextMatchBtn" disabled>Next ‚ñ∂</button>
        </div>
        
        <div style="margin-top:12px">
          <button class="btn btn-primary" id="checkBalanceBtn" style="display:none">
            ‚öñÔ∏è CHECK & BALANCE
            <span style="margin-left:6px;background:linear-gradient(45deg,#9b59b6,#8e44ad);padding:2px 8px;border-radius:6px">Consensus Mode</span>
          </button>
          <!-- NEW: FORECAST BUTTON - FIXED SPELLING -->
          <button class="btn btn-forecast" id="forecastBtn" style="display:none">
            üìà FORECAST
            <span style="margin-left:6px;background:linear-gradient(45deg,#0066ff,#00bfff);padding:2px 8px;border-radius:6px">1-5 Year Projection</span>
          </button>
        </div>
      </div>

      <div class="card" style="margin-top:12px">
        <div class="response-header">
          <h3>‚öñÔ∏è Consensus Visualization</h3>
          <div>Radar Metrics</div>
        </div>
        <canvas id="consensusChart" height="260"></canvas>
        <div class="consensus-block" id="consensusBlock" style="margin-top:12px;display:none"></div>
      </div>
    </section>

    <!-- DATABASE STORAGE: Upload + Library + Database Connections -->
    <section id="panel-storage" class="panel">
      <div class="card col-12">
        <h3>üîó DATABASE CONNECTIONS</h3>
        
        <!-- Connection Guide -->
        <div style="background: rgba(255,165,0,.1); border: 1px solid var(--warn); border-radius: 8px; padding: 12px; margin-bottom: 16px;">
          <strong>üìã Connection Options:</strong>
          <div style="font-size: 0.8rem; margin-top: 8px;">
            ‚Ä¢ <strong>SQLite Files:</strong> Direct connection - perfect for NAS storage<br>
            ‚Ä¢ <strong>Excel Files:</strong> Direct connection for .xlsx and .xls files<br>
            ‚Ä¢ <strong>CSV Files:</strong> Direct connection for .csv files<br>
            ‚Ä¢ <strong>Server Databases:</strong> PostgreSQL, MySQL, Oracle, SQL Server<br>
            ‚Ä¢ <strong>Backend Required:</strong> Set up Bathala backend on your NAS<br>
            ‚Ä¢ <strong>Quick Start:</strong> Export server databases to SQLite format
          </div>
        </div>

        <div class="database-connections" id="databaseConnections">
          <!-- Database connection cards will be added here dynamically -->
        </div>

        <div class="add-connection-btn" id="addConnectionBtn">
          <div style="font-size: 2rem; margin-bottom: 8px;">‚ûï</div>
          <div>Add Database Connection</div>
          <div style="font-size: 0.8rem; color: var(--muted); margin-top: 4px;">
            SQLite ‚Ä¢ Excel ‚Ä¢ CSV ‚Ä¢ PostgreSQL ‚Ä¢ MySQL ‚Ä¢ Oracle ‚Ä¢ SQL Server
          </div>
        </div>
      </div>

      <div class="card col-12" style="border-style:dashed; margin-top: 20px;">
        <h3>üìö FILE DATABASE STORAGE</h3>
        <input type="file" id="fileInput" accept=".pdf,.docx,.txt,.jpg,.png,.jpeg,.doc,.xlsx,.xls,.pptx,.ppt,.csv,.rtf,.odt,.ods,.odp" multiple>
        <div style="margin-top:8px;color:var(--muted)">PDF, DOCX, TXT, JPG, PNG, XLSX, PPTX, CSV, RTF (Max 50MB each)</div>
        <div id="fileProcessingInfo" style="display:none;margin-top:8px">
          <div class="loading-wrap" id="globalSpinner"><div class="spinner3d"></div><span id="spinnerText">Processing‚Ä¶</span></div>
          <div id="processingFileName" class="tagline"></div>
          <div id="processingStatus"></div>
          <div id="pageProgress" class="tagline"></div>
          <div style="background:rgba(0,0,0,.3);border-radius:10px;overflow:hidden;margin-top:8px">
            <div id="progressBar" style="height:18px;width:0%;background:linear-gradient(90deg,#ffdf6b,#00ff88);text-align:center;color:#000;font-weight:800;transition:width .2s"></div>
          </div>
        </div>
      </div>

      <div class="card col-12" style="margin-top: 20px;">
        <h3>üìö LIBRARY</h3>
        <div id="documentsList"></div>
      </div>
    </section>

    <!-- AGENTS CONFIGURATION -->
    <section id="panel-agents" class="panel">
      <div class="grid">
        <div class="card col-4">
          <h3>üî∑ AI Agent 1</h3>
          <label>API KEY</label>
          <input type="password" id="deepseekKey" placeholder="sk-xxxxxxxx" />
          <div style="display:flex;align-items:center;gap:8px;margin-top:10px">
            <div class="status-dot" id="deepseekStatus"></div>
            <span id="deepseekStatusText">Not configured</span>
          </div>
        </div>
        <div class="card col-4">
          <h3>‚ö° AI Agent 2</h3>
          <label>API KEY</label>
          <input type="password" id="openaiKey" placeholder="sk-xxxxxxxx" />
          <div style="display:flex;align-items:center;gap:8px;margin-top:10px">
            <div class="status-dot" id="openaiStatus"></div>
            <span id="openaiStatusText">Not configured</span>
          </div>
        </div>
        <div class="card col-4">
          <h3>üéØ AI Agent 3</h3>
          <label>API KEY</label>
          <input type="password" id="grokKey" placeholder="xai-xxxxxxxx" />
          <div style="display:flex;align-items:center;gap:8px;margin-top:10px">
            <div class="status-dot" id="grokStatus"></div>
            <span id="grokStatusText">Not configured</span>
          </div>
        </div>
      </div>
      <div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:12px">
        <button class="btn btn-primary" id="connectAgentsBtn">üõ°Ô∏è CONNECT AGENTS</button>
        <button class="btn btn-primary" id="saveConfigBtn">üíæ SAVE CONFIGURATION</button>
        <button class="btn btn-danger" id="disconnectAgentsBtn">üîå DISCONNECT AGENTS</button>
      </div>
    </section>

    <div class="card" style="margin-top:12px;display:flex;align-items:center;gap:10px">
      <div class="status-dot" id="globalStatus"></div>
      <span id="statusText">BATHALA INTELLIGENCE: Configure AI Agents to begin</span>
    </div>

    <footer>¬© 2025 by Dimax Technologies Center. Powered and secured by RP8</footer>
  </main>
</div>

<div class="toast-stack" id="toastStack"></div>

<script>
// ===== Utilities
const $ = (q) => document.querySelector(q);
const $$ = (q) => document.querySelectorAll(q);
const byId = (id) => document.getElementById(id);
const show = (el) => { if(el) el.style.display = ''; };
const hide = (el) => { if(el) el.style.display = 'none'; };

function toast(msg, type = 'success') {
  const stack = $('#toastStack');
  const item = document.createElement('div');
  item.className = `toast ${type}`;

  const dot = document.createElement('div');
  dot.className = 'dot';
  dot.style.background = type === 'success' ? 'var(--neon)' :
                        type === 'error' ? 'var(--error)' : 'var(--warn)';

  const span = document.createElement('div');
  span.innerHTML = msg;

  item.append(dot, span);
  stack.appendChild(item);

  setTimeout(() => {
    item.style.opacity = '0';
    item.style.transform = 'translateY(8px)';
  }, 2600);

  setTimeout(() => item.remove(), 3100);
}

// PDF.js worker
pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';

// ===== Hybrid Database Connection Management
const DATABASE_TEMPLATES = {
  sqlite: {
    name: 'SQLite Database File',
    icon: 'üóÉÔ∏è',
    type: 'file',
    connectionType: 'direct',
    description: 'Connect to SQLite database files - perfect for NAS storage',
    fields: [
      { name: 'name', label: 'Connection Name', placeholder: 'My SQLite Database', type: 'text', required: true },
      { name: 'filePath', label: 'SQLite File', placeholder: 'Select .db, .sqlite, or .sqlite3 file', type: 'file', accept: '.db,.sqlite,.sqlite3', required: true },
      { name: 'description', label: 'Description', placeholder: 'e.g., Customer database from NAS storage', type: 'textarea' }
    ]
  },
  
  excel: {
    name: 'Excel File',
    icon: 'üìä',
    type: 'file',
    connectionType: 'direct',
    description: 'Connect to Excel files (.xlsx, .xls) - direct browser access',
    fields: [
      { name: 'name', label: 'Connection Name', placeholder: 'My Excel Database', type: 'text', required: true },
      { name: 'filePath', label: 'Excel File', placeholder: 'Select .xlsx or .xls file', type: 'file', accept: '.xlsx,.xls', required: true },
      { name: 'description', label: 'Description', placeholder: 'e.g., Sales data spreadsheet', type: 'textarea' }
    ]
  },
  
  csv: {
    name: 'CSV File',
    icon: 'üìã',
    type: 'file',
    connectionType: 'direct',
    description: 'Connect to CSV files - direct browser access',
    fields: [
      { name: 'name', label: 'Connection Name', placeholder: 'My CSV Database', type: 'text', required: true },
      { name: 'filePath', label: 'CSV File', placeholder: 'Select .csv file', type: 'file', accept: '.csv', required: true },
      { name: 'description', label: 'Description', placeholder: 'e.g., Customer data export', type: 'textarea' }
    ]
  },
  
  postgresql: {
    name: 'PostgreSQL Server',
    icon: 'üêò',
    type: 'server',
    connectionType: 'backend',
    description: 'Connect to PostgreSQL server (requires backend API)',
    fields: [
      { name: 'name', label: 'Connection Name', placeholder: 'NAS PostgreSQL Server', type: 'text', required: true },
      { name: 'host', label: 'Server Host', placeholder: '192.168.1.100 (your NAS IP)', type: 'text', required: true },
      { name: 'port', label: 'Port', placeholder: '5432', type: 'text', default: '5432', required: true },
      { name: 'database', label: 'Database Name', type: 'text', required: true },
      { name: 'username', label: 'Username', type: 'text', required: true },
      { name: 'password', label: 'Password', type: 'password', required: true },
      { name: 'description', label: 'Description', placeholder: 'e.g., Production database on NAS', type: 'textarea' }
    ]
  },
  mysql: {
    name: 'MySQL Server', 
    icon: 'üê¨',
    type: 'server',
    connectionType: 'backend',
    description: 'Connect to MySQL server (requires backend API)',
    fields: [
      { name: 'name', label: 'Connection Name', placeholder: 'NAS MySQL Server', type: 'text', required: true },
      { name: 'host', label: 'Server Host', placeholder: '192.168.1.100 (your NAS IP)', type: 'text', required: true },
      { name: 'port', label: 'Port', placeholder: '3306', type: 'text', default: '3306', required: true },
      { name: 'database', label: 'Database Name', type: 'text', required: true },
      { name: 'username', label: 'Username', type: 'text', required: true },
      { name: 'password', label: 'Password', type: 'password', required: true }
    ]
  },
  oracle: {
    name: 'Oracle Database',
    icon: 'üóÑÔ∏è',
    type: 'server',
    connectionType: 'backend',
    description: 'Connect to Oracle Database (requires backend API)',
    fields: [
      { name: 'name', label: 'Connection Name', placeholder: 'Production Oracle DB', type: 'text', required: true },
      { name: 'host', label: 'Server Host', placeholder: '192.168.1.100 (your NAS IP)', type: 'text', required: true },
      { name: 'port', label: 'Port', placeholder: '1521', type: 'text', default: '1521', required: true },
      { name: 'service', label: 'Service Name', placeholder: 'ORCL', type: 'text', required: true },
      { name: 'username', label: 'Username', type: 'text', required: true },
      { name: 'password', label: 'Password', type: 'password', required: true }
    ]
  },
  mssql: {
    name: 'SQL Server',
    icon: 'üè¢',
    type: 'server',
    connectionType: 'backend',
    description: 'Connect to Microsoft SQL Server (requires backend API)',
    fields: [
      { name: 'name', label: 'Connection Name', placeholder: 'Enterprise SQL Server', type: 'text', required: true },
      { name: 'host', label: 'Server Host', placeholder: '192.168.1.100 (your NAS IP)', type: 'text', required: true },
      { name: 'port', label: 'Port', placeholder: '1433', type: 'text', default: '1433', required: true },
      { name: 'database', label: 'Database Name', type: 'text', required: true },
      { name: 'username', label: 'Username', type: 'text', required: true },
      { name: 'password', label: 'Password', type: 'password', required: true }
    ]
  }
};

// ===== API CONFIG =====
const API_CONFIG = {
  deepseek: {
    name: 'AI Agent 1',
    proxyUrl: '/api/proxy/deepseek',
    model: 'deepseek-chat'
  },
  openai: {
    name: 'AI Agent 2',
    proxyUrl: '/api/proxy/openai',
    model: 'gpt-3.5-turbo'
  },
  grok: {
    name: 'AI Agent 3',
    proxyUrl: '/api/proxy/grok',
    model: 'grok-code-fast-1'
  }
};

// ===== SMART PROXY DETECTION =====
function getApiUrl(provider) {
  const isVercel = window.location.hostname.includes('vercel.app');
  const isLocalhost = window.location.hostname.includes('localhost');
  
  if (isVercel || isLocalhost) {
    return API_CONFIG[provider].proxyUrl;
  } else {
    return API_CONFIG[provider].proxyUrl || API_CONFIG[provider].apiUrl;
  }
}

// ===== UPDATED QUERYAI FUNCTION =====
async function queryAI(provider, query, apiKey, persona) {
  const start = Date.now();
  const system = PERSONA[persona || 'strategist'];
  const model = API_CONFIG[provider].model;

  const fp = await fingerprintOf({ provider, model, persona, query });
  const cached = await knowledgeBase.getResponse(fp);

  if (cached) {
    return { success: true, content: cached.content, responseTime: 0, cached: true };
  }

  try {
    const apiUrl = getApiUrl(provider);
    
    const res = await fetch(apiUrl, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        model,
        messages: [
          { role: 'system', content: system },
          { role: 'user', content: query }
        ],
        max_tokens: 1000,
        temperature: 0.7
      })
    });

    if (!res.ok) {
      const t = await res.text();
      throw new Error(`API ${res.status} - ${t}`);
    }

    const data = await res.json();
    const content = data.choices?.[0]?.message?.content || '[No content]';

    await knowledgeBase.putResponse(fp, { content, at: Date.now() });
    return { success: true, content, responseTime: Date.now() - start };
  } catch (e) {
    console.error(`${provider} API error:`, e);
    
    if (e.message.includes('NetworkError') || e.message.includes('Failed to fetch')) {
      return { 
        success: false, 
        error: `CORS/Network Error. When deploying to Vercel, you need to add a proxy server file. Create '/api/proxy.js' with the code provided in the deployment instructions.`,
        responseTime: Date.now() - start 
      };
    }
    
    return { success: false, error: e.message, responseTime: Date.now() - start };
  }
}

// ===== UPDATED TEST API CONNECTION =====
async function testApiConnection(provider) {
  const apiKeyEl = byId(`${provider}Key`);
  const apiKey = apiKeyEl?.value;

  if (!apiKey) {
    updateApiStatus(provider, 'error', 'No API key provided');
    return false;
  }

  try {
    const testQuery = "Hello";
    const system = "You are a test agent. Respond with 'Connection successful' if you receive this message.";
    
    const apiUrl = getApiUrl(provider);
    
    const res = await fetch(apiUrl, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        model: API_CONFIG[provider].model,
        messages: [
          { role: 'system', content: system },
          { role: 'user', content: testQuery }
        ],
        max_tokens: 10
      })
    });

    if (res.ok) {
      updateApiStatus(provider, 'connected');
      return true;
    }

    const errorText = await res.text();
    updateApiStatus(provider, 'error', `HTTP ${res.status}`);
    return false;
  } catch (e) {
    if (e.message.includes('NetworkError') || e.message.includes('Failed to fetch')) {
      updateApiStatus(provider, 'saved', 'Configured (proxy needed for Vercel)');
      return true;
    }
    
    updateApiStatus(provider, 'error', `Connection failed: ${e.message}`);
    return false;
  }
}

// ===== Persona prompts =====
const PERSONA = {
  analyst: `You are Bathala (Analyst). Be precise, statistical, cite assumptions, provide numbered steps and short tables when helpful.`,
  ethicist: `You are Bathala (Ethicist). Prioritize safety, fairness, consent, governance impacts. Highlight tradeoffs and ethical risks.`,
  strategist: `You are Bathala (Strategist). Optimize for impact. Provide action plans, decision trees, and clear prioritization.`,
  creative: `You are Bathala (Creative). Provide novel ideas, metaphors, and multiple alternatives. Keep it practical.`
};

// ===== Sidebar navigation =====
function activatePanel(name) {
  document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
  const panel = document.querySelector(`#panel-${name}`);
  if (panel) {
    panel.classList.add('active');
  } else {
    console.warn(`Panel not found: ${name}`);
  }
}

document.querySelectorAll('.nav button').forEach(button => {
  button.addEventListener('click', () => {
    document.querySelectorAll('.nav button').forEach(b => b.classList.remove('active'));
    button.classList.add('active');
    const target = button.getAttribute('data-panel');
    activatePanel(target);
  });
});

console.log('Bathala v6.0: Navigation system loaded.');

// ===== Status helpers =====
function updateApiStatus(provider, status, message) {
  const dot = byId(`${provider}Status`);
  const text = byId(`${provider}StatusText`);
  if (!dot || !text) return;

  switch (status) {
    case 'connected':
      dot.className = 'status-dot connected';
      text.textContent = 'Connected ‚úì';
      text.style.color = 'var(--neon)';
      break;
    case 'saved':
      dot.className = 'status-dot';
      text.textContent = message || 'Configured (not tested)';
      text.style.color = 'var(--warn)';
      break;
    case 'error':
      dot.className = 'status-dot';
      text.textContent = message || 'Connection failed';
      text.style.color = 'var(--error)';
      break;
    default:
      dot.className = 'status-dot';
      text.textContent = 'Not configured';
      text.style.color = '#ccc';
  }
}

function loadApiKeys() {
  ['deepseek', 'openai', 'grok'].forEach(p => {
    const k = localStorage.getItem(`${p}_api_key`);
    if (k) {
      const el = byId(`${p}Key`);
      if (el) el.value = k;
      updateApiStatus(p, 'saved');
    }
  });
}

function disconnectAgents() {
  ['deepseek', 'openai', 'grok'].forEach(p => updateApiStatus(p, 'disconnected'));
  byId('globalStatus').className = 'status-dot';
  byId('statusText').textContent = 'BATHALA INTELLIGENCE: All agents disconnected';
}

// ===== Knowledge Base (IndexedDB) - ENHANCED WITH PAGES =====
class LocalKnowledgeBase {
  constructor() {
    this.db = null;
    this.ready = this.initDatabase();
  }

  async initDatabase() {
    return new Promise((resolve, reject) => {
      const req = indexedDB.open('BathalaKB_v7', 3); // Incremented version

      req.onerror = () => reject(req.error);
      req.onsuccess = () => { this.db = req.result; resolve(); };

      req.onupgradeneeded = (e) => {
        const db = e.target.result;

        // Documents store with enhanced indexing
        if (!db.objectStoreNames.contains('documents')) {
          const s = db.createObjectStore('documents', { keyPath: 'id' });
          s.createIndex('filename', 'filename');
          s.createIndex('uploadDate', 'uploadDate');
          s.createIndex('searchableContent', 'searchableContent');
          s.createIndex('conversionType', 'conversionType');
        }

        // Pages store for PDF page-by-page storage
        if (!db.objectStoreNames.contains('pages')) {
          const p = db.createObjectStore('pages', { keyPath: 'id' });
          p.createIndex('documentId', 'documentId');
          p.createIndex('pageNumber', 'pageNumber');
          p.createIndex('content', 'content');
        }

        if (!db.objectStoreNames.contains('responses')) {
          const r = db.createObjectStore('responses', { keyPath: 'fingerprint' });
          r.createIndex('createdAt', 'createdAt');
        }

        if (!db.objectStoreNames.contains('history')) {
          const h = db.createObjectStore('history', { keyPath: 'id' });
          h.createIndex('type', 'type');
          h.createIndex('createdAt', 'createdAt');
        }
      };
    });
  }

  async storeDocument(file, fullContent, searchableContent, conversionType, pages = []) {
    await this.ready;

    const doc = {
      id: `${Date.now()}_${file.name}`,
      filename: file.name,
      content: fullContent,
      searchableContent: (searchableContent || '').toLowerCase(),
      uploadDate: new Date(),
      fileType: file.type,
      size: file.size,
      wordCount: (searchableContent || '').split(/\s+/).filter(Boolean).length,
      storagePath: 'Ai CHIP',
      conversionType: conversionType || 'Direct Processing',
      pageCount: pages.length
    };

    const tx = this.db.transaction(['documents', 'pages'], 'readwrite');
    const docStore = tx.objectStore('documents');
    const pageStore = tx.objectStore('pages');
    
    await docStore.put(doc);
    
    // Store pages if provided
    for (const page of pages) {
      const pageRecord = {
        id: `${doc.id}_page_${page.pageNumber}`,
        documentId: doc.id,
        pageNumber: page.pageNumber,
        content: page.content,
        isOCR: page.isOCR || false
      };
      await pageStore.put(pageRecord);
    }
    
    return doc;
  }

  async getAllDocuments() {
    await this.ready;
    const tx = this.db.transaction(['documents'], 'readonly');
    const st = tx.objectStore('documents');

    return new Promise((resolve, reject) => {
      const r = st.getAll();
      r.onsuccess = () => resolve(r.result);
      r.onerror = () => reject(r.error);
    });
  }

  async getDocumentPages(documentId) {
    await this.ready;
    const tx = this.db.transaction(['pages'], 'readonly');
    const st = tx.objectStore('pages');
    const idx = st.index('documentId');
    
    return new Promise((resolve, reject) => {
      const r = idx.getAll(documentId);
      r.onsuccess = () => resolve(r.result.sort((a, b) => a.pageNumber - b.pageNumber));
      r.onerror = () => reject(r.error);
    });
  }

  async deleteDocument(id) {
    await this.ready;
    const tx = this.db.transaction(['documents', 'pages'], 'readwrite');
    const docStore = tx.objectStore('documents');
    const pageStore = tx.objectStore('pages');
    const idx = pageStore.index('documentId');
    
    // First delete all pages
    const pages = await new Promise((resolve) => {
      const r = idx.getAll(id);
      r.onsuccess = () => resolve(r.result);
      r.onerror = () => resolve([]);
    });
    
    for (const page of pages) {
      await pageStore.delete(page.id);
    }
    
    // Then delete the document
    await docStore.delete(id);
  }

  async searchDocumentsExact(query) {
    await this.ready;
    const docs = await this.getAllDocuments();
    if (docs.length === 0) return [];

    const queryLower = query.toLowerCase();
    const terms = queryLower.split(/\s+/).filter(t => t.length > 0);
    const results = [];

    for (const d of docs) {
      const content = d.content.toLowerCase();
      const searchable = d.searchableContent || '';
      const fname = d.filename.toLowerCase();
      let score = 0;
      let matches = [];
      let exactMatches = 0;

      // Search in filename
      if (fname.includes(queryLower)) {
        score += 20;
        matches.push(`Filename contains "${query}"`);
      }

      // Search in searchable content (exact matches)
      if (searchable) {
        const searchableTerms = searchable.split(/\s+/);
        
        // Count exact word matches
        for (const term of terms) {
          const termRegex = new RegExp(`\\b${term}\\b`, 'gi');
          const termMatches = (searchable.match(termRegex) || []).length;
          exactMatches += termMatches;
          score += termMatches * 10;
          
          if (termMatches > 0) {
            matches.push(`Found "${term}" ${termMatches} time(s)`);
          }
        }
      }

      // Search in full content (fallback)
      if (content && content.length > 0) {
        for (const term of terms) {
          const termRegex = new RegExp(`\\b${term}\\b`, 'gi');
          const termMatches = (content.match(termRegex) || []).length;
          if (termMatches > 0) {
            score += termMatches * 5;
            matches.push(`Found "${term}" ${termMatches} time(s) in full content`);
          }
        }
      }

      if (score > 0) {
        results.push({ 
          d, 
          score,
          exactMatches,
          matches,
          hasSearchableContent: !!searchable && searchable.length > 0,
          searchableLength: searchable?.length || 0
        });
      }
    }

    return results.sort((a, b) => b.score - a.score).map(r => r.d);
  }

  async searchDocumentPages(documentId, query) {
    await this.ready;
    const pages = await this.getDocumentPages(documentId);
    if (pages.length === 0) return [];

    const queryLower = query.toLowerCase();
    const terms = queryLower.split(/\s+/).filter(t => t.length > 0);
    const matchingPages = [];

    for (const page of pages) {
      const content = page.content.toLowerCase();
      let score = 0;
      let matches = [];
      
      for (const term of terms) {
        const termRegex = new RegExp(`\\b${term}\\b`, 'gi');
        const termMatches = (content.match(termRegex) || []).length;
        if (termMatches > 0) {
          score += termMatches * 10;
          matches.push({
            term,
            count: termMatches,
            positions: []
          });
        }
      }
      
      if (score > 0) {
        matchingPages.push({
          page,
          score,
          matches,
          totalMatches: matches.reduce((sum, m) => sum + m.count, 0)
        });
      }
    }

    return matchingPages.sort((a, b) => b.score - a.score);
  }

  async putResponse(fingerprint, payload) {
    await this.ready;
    const tx = this.db.transaction(['responses'], 'readwrite');
    const st = tx.objectStore('responses');
    await st.put({ fingerprint, payload, createdAt: Date.now() });
  }

  async getResponse(fingerprint) {
    await this.ready;
    const tx = this.db.transaction(['responses'], 'readonly');
    const st = tx.objectStore('responses');

    return new Promise((resolve) => {
      const r = st.get(fingerprint);
      r.onsuccess = () => resolve(r.result?.payload || null);
      r.onerror = () => resolve(null);
    });
  }

  async pushHistory(entry) {
    await this.ready;
    const id = `${Date.now()}_${Math.random().toString(36).slice(2, 7)}`;
    const tx = this.db.transaction(['history'], 'readwrite');
    const st = tx.objectStore('history');
    await st.put({ id, ...entry, createdAt: Date.now() });
  }

  async listHistory(type, limit = 8) {
    await this.ready;
    const tx = this.db.transaction(['history'], 'readonly');
    const st = tx.objectStore('history');
    const idx = st.index('createdAt');

    return new Promise((resolve) => {
      const out = [];
      idx.openCursor(null, 'prev').onsuccess = (e) => {
        const cur = e.target.result;
        if (cur) {
          if (!type || cur.value.type === type) {
            out.push(cur.value);
            if (out.length >= limit) return resolve(out);
          }
          cur.continue();
        } else {
          resolve(out);
        }
      };
    });
  }
}

const knowledgeBase = new LocalKnowledgeBase();

// Simple SHA-256 fingerprint
async function fingerprintOf(obj) {
  const enc = new TextEncoder().encode(JSON.stringify(obj));
  const digest = await crypto.subtle.digest('SHA-256', enc);
  return Array.from(new Uint8Array(digest)).map(b => b.toString(16).padStart(2, '0')).join('');
}

// ===== IMPROVED File Processor - CONSISTENT PDF/OCR =====
class EnhancedFileProcessor {
  constructor() {
    this.ocrWorker = null;
    this.initOCR();
  }

  async initOCR() {
    try {
      this.ocrWorker = await Tesseract.createWorker('eng', 1, {
        logger: m => console.log('OCR:', m),
        errorHandler: e => console.error('OCR Error:', e)
      });
      await this.ocrWorker.setParameters({
        preserve_interword_spaces: '1',
        tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 .,!?;:()-"\'\n\r\t',
        tessedit_pageseg_mode: '3' // Auto page segmentation
      });
    } catch (e) {
      console.error('Failed to initialize OCR worker:', e);
    }
  }

  showProgress() {
    const info = byId('fileProcessingInfo');
    if (info) info.style.display = 'block';

    const sp = byId('globalSpinner');
    if (sp) sp.classList.add('active');
  }

  hideProgress() {
    const sp = byId('globalSpinner');
    if (sp) sp.classList.remove('active');

    const bar = byId('progressBar');
    if (bar) {
      bar.style.width = '0%';
      bar.textContent = '';
    }

    const info = byId('fileProcessingInfo');
    if (info) {
      setTimeout(() => {
        info.style.display = 'none';
        byId('spinnerText').textContent = 'Processing‚Ä¶';
      }, 500);
    }
  }

  updateProgress(name, status, percent, cur = 0, total = 0, ocr = 0) {
    byId('processingFileName').textContent = `Processing: ${name}`;
    byId('processingStatus').textContent = status;
    byId('pageProgress').textContent = total ? `Page ${cur} of ${total} ‚Ä¢ OCR: ${ocr}` : '';

    const bar = byId('progressBar');
    const sp = byId('globalSpinner');
    const st = byId('spinnerText');

    if (bar) {
      bar.style.width = `${percent}%`;
      bar.textContent = `${Math.round(percent)}%`;

      if (percent < 50) {
        bar.style.background = 'linear-gradient(90deg, #ff6b6b, #ffdf6b)';
      } else if (percent < 100) {
        bar.style.background = 'linear-gradient(90deg, #ffdf6b, #00cc6a)';
      } else {
        bar.style.background = 'linear-gradient(90deg, #00cc6a, #00ff88)';
      }
    }

    if (percent >= 100) {
      if (sp) sp.classList.remove('active');
      if (st) st.textContent = 'Completed';
      setTimeout(() => { this.hideProgress(); }, 900);
    }
  }

  async extractTextFromPDFPage(page, pageNumber, forceOCR = false) {
    try {
      // Try text extraction first (unless forceOCR is true)
      if (!forceOCR) {
        const textContent = await page.getTextContent();
        const pageText = textContent.items.map(item => item.str).join(' ');
        
        // Check if we got meaningful text (more than just a few characters)
        if (pageText.trim().length > 50) {
          return {
            success: true,
            text: pageText,
            isOCR: false,
            confidence: 'high'
          };
        }
      }
      
      // Use OCR for low-text or forced OCR pages
      const viewport = page.getViewport({ scale: 2.0 }); // Higher scale for better OCR
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      
      canvas.width = viewport.width;
      canvas.height = viewport.height;
      
      await page.render({
        canvasContext: context,
        viewport: viewport
      }).promise;
      
      // Use Tesseract OCR
      if (this.ocrWorker) {
        const { data: { text, confidence } } = await this.ocrWorker.recognize(canvas);
        
        return {
          success: true,
          text: text || '',
          isOCR: true,
          confidence: confidence || 0
        };
      } else {
        // Fallback: Try to initialize OCR worker
        await this.initOCR();
        if (this.ocrWorker) {
          const { data: { text, confidence } } = await this.ocrWorker.recognize(canvas);
          
          return {
            success: true,
            text: text || '',
            isOCR: true,
            confidence: confidence || 0
          };
        }
      }
      
      return {
        success: false,
        text: '',
        isOCR: false,
        confidence: 0
      };
    } catch (error) {
      console.error(`Error processing page ${pageNumber}:`, error);
      return {
        success: false,
        text: `[Error processing page ${pageNumber}]`,
        isOCR: false,
        confidence: 0
      };
    }
  }

  async processPDF(file) {
    try {
      const buf = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({ 
        data: buf,
        disableFontFace: true,
        useSystemFonts: true
      }).promise;
      
      const totalPages = pdf.numPages;
      let allText = '';
      let allSearchableText = '';
      let ocrPages = 0;
      let textPages = 0;
      const pages = [];
      
      this.showProgress();
      this.updateProgress(file.name, 'Initializing PDF processing...', 5);

      // Process each page
      for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
        this.updateProgress(file.name, `Processing page ${pageNum}/${totalPages}`, 
                          ((pageNum - 1) / totalPages) * 90 + 5, pageNum, totalPages, ocrPages);

        try {
          const page = await pdf.getPage(pageNum);
          const result = await this.extractTextFromPDFPage(page, pageNum);
          
          let pageText = result.text || '';
          let isOCR = result.isOCR;
          
          // If text is very short, try OCR
          if (pageText.trim().length < 100 && !isOCR) {
            const ocrResult = await this.extractTextFromPDFPage(page, pageNum, true);
            if (ocrResult.success && ocrResult.text.trim().length > pageText.trim().length) {
              pageText = ocrResult.text;
              isOCR = true;
            }
          }
          
          if (isOCR) {
            ocrPages++;
            allText += `[OCR Page ${pageNum}]: ${pageText}\n\n`;
          } else {
            textPages++;
            allText += `Page ${pageNum}: ${pageText}\n\n`;
          }
          
          // Store page individually
          pages.push({
            pageNumber: pageNum,
            content: pageText.toLowerCase(),
            isOCR: isOCR
          });
          
          allSearchableText += pageText.toLowerCase() + ' ';
          
        } catch (pageError) {
          console.error(`Error on page ${pageNum}:`, pageError);
          allText += `[Error on page ${pageNum}]\n\n`;
        }
      }

      this.updateProgress(file.name, 'Finalizing...', 98, totalPages, totalPages, ocrPages);
      
      // Clean up OCR worker
      if (this.ocrWorker) {
        await this.ocrWorker.terminate();
        this.ocrWorker = null;
      }

      this.updateProgress(file.name, 'Completed!', 100);

      return {
        text: allText || '[No readable text]',
        searchableText: allSearchableText.trim(),
        info: `PDF ${totalPages} pages, ${textPages} text, ${ocrPages} OCR`,
        conversionType: ocrPages > 0 ? 'OCR Enhanced' : 'Direct Text Extraction',
        pages: pages
      };
    } catch (e) {
      console.error('PDF processing error:', e);
      this.updateProgress(file.name, 'PDF processing failed', 100);
      
      if (this.ocrWorker) {
        await this.ocrWorker.terminate();
        this.ocrWorker = null;
      }
      
      return {
        text: '[PDF processing failed]',
        searchableText: '',
        info: 'PDF processing error',
        conversionType: 'Failed',
        pages: []
      };
    }
  }

  async extractText(file) {
    try {
      if (file.size > 50 * 1024 * 1024) {
        return {
          success: false,
          content: `File "${file.name}" is too large.`,
          extractedText: '',
          searchableText: ''
        };
      }

      this.showProgress();
      this.updateProgress(file.name, 'Starting‚Ä¶', 10);

      if (file.type.includes('pdf') || file.name.toLowerCase().endsWith('.pdf')) {
        const r = await this.processPDF(file);
        return {
          success: true,
          content: this.buildMeta(file, r.info, r.conversionType) + "\n\n" + r.text,
          extractedText: r.text,
          searchableText: r.searchableText,
          conversionType: r.conversionType,
          pages: r.pages
        };
      }

      if (file.type.includes('image')) {
        this.updateProgress(file.name, 'Processing image with OCR‚Ä¶', 30);
        
        if (!this.ocrWorker) {
          await this.initOCR();
        }
        
        const { data: { text } } = await this.ocrWorker.recognize(file);
        
        this.updateProgress(file.name, 'Completed', 100);

        return {
          success: true,
          content: this.buildMeta(file, 'OCR completed', 'OCR Processing') + "\n\n" + text,
          extractedText: text,
          searchableText: text.toLowerCase(),
          conversionType: 'OCR Processing',
          pages: [{
            pageNumber: 1,
            content: text.toLowerCase(),
            isOCR: true
          }]
        };
      }

      if (file.name.toLowerCase().endsWith('.docx')) {
        this.updateProgress(file.name, 'Processing DOCX‚Ä¶', 40);
        const ab = await file.arrayBuffer();
        const r = await mammoth.extractRawText({ arrayBuffer: ab });
        const txt = r.value || 'No text';
        this.updateProgress(file.name, 'Completed', 100);

        return {
          success: true,
          content: this.buildMeta(file, 'DOCX processed', 'Direct Processing') + "\n\n" + txt,
          extractedText: txt,
          searchableText: txt.toLowerCase(),
          conversionType: 'Direct Processing',
          pages: [{
            pageNumber: 1,
            content: txt.toLowerCase(),
            isOCR: false
          }]
        };
      }

      if (file.name.toLowerCase().match(/\.(xlsx|xls)$/)) {
        this.updateProgress(file.name, 'Processing Excel‚Ä¶', 50);
        const ab = await file.arrayBuffer();
        const wb = XLSX.read(new Uint8Array(ab), { type: 'array' });
        let txt = '';
        let searchable = '';

        wb.SheetNames.forEach(s => {
          const ws = wb.Sheets[s];
          const sheetText = XLSX.utils.sheet_to_csv(ws);
          txt += `Sheet: ${s}\n` + sheetText + "\n\n";
          searchable += sheetText.toLowerCase() + ' ';
        });

        this.updateProgress(file.name, 'Completed', 100);

        return {
          success: true,
          content: this.buildMeta(file, `Excel processed: ${wb.SheetNames.length} sheets`, 'Direct Processing') + "\n\n" + txt,
          extractedText: txt,
          searchableText: searchable.trim(),
          conversionType: 'Direct Processing',
          pages: [{
            pageNumber: 1,
            content: searchable.toLowerCase(),
            isOCR: false
          }]
        };
      }

      // Fallback text
      this.updateProgress(file.name, 'Reading text‚Ä¶', 60);
      const txt = await new Promise((resolve) => {
        const r = new FileReader();
        r.onload = e => resolve(e.target.result || '');
        r.readAsText(file);
      });

      this.updateProgress(file.name, 'Completed', 100);

      return {
        success: true,
        content: this.buildMeta(file, 'Text file processed', 'Direct Processing') + "\n\n" + txt,
        extractedText: txt,
        searchableText: txt.toLowerCase(),
        conversionType: 'Direct Processing',
        pages: [{
          pageNumber: 1,
          content: txt.toLowerCase(),
          isOCR: false
        }]
      };
    } catch (e) {
      console.error('File processing error:', e);
      this.updateProgress(file.name, 'Completed with warnings', 100);
      return {
        success: true,
        content: this.buildMeta(file, 'Processing completed', 'Basic Processing') + "\n\nFile stored successfully.",
        extractedText: 'File stored',
        searchableText: '',
        conversionType: 'Basic Processing',
        pages: []
      };
    }
  }

  buildMeta(file, info, conv) {
    return `FILE: ${file.name}
TYPE: ${file.type}
SIZE: ${(file.size / (1024 * 1024)).toFixed(2)}MB
STORAGE_PATH: Ai CHIP
UPLOAD_DATE: ${new Date().toLocaleString()}
PROCESSING_INFO: ${info}
CONVERSION_TYPE: ${conv}`;
  }

  async processFiles(files) {
    try {
      for (let i = 0; i < files.length; i++) {
        const f = files[i];
        const r = await this.extractText(f);

        if (r.success) {
          await knowledgeBase.storeDocument(f, r.content, r.searchableText, r.conversionType, r.pages);
          
          console.log('File processed successfully:', {
            name: f.name,
            hasSearchableText: !!r.searchableText,
            searchableLength: r.searchableText?.length,
            conversionType: r.conversionType,
            pages: r.pages?.length || 0
          });
          
          toast(`Stored <b>${f.name}</b> in Library (${r.pages?.length || 1} pages)`, 'success');
        } else {
          toast(r.content, 'error');
        }
      }
    } finally {
      this.hideProgress();
      await updateDocumentsList();
    }
  }
}

const fileProcessor = new EnhancedFileProcessor();

// ===== Search State Management =====
let currentSearchState = {
  query: '',
  results: [],
  currentDocumentIndex: 0,
  currentPageIndex: 0,
  currentMatchIndex: 0,
  totalMatches: 0
};

// Documents list renderers
async function renderDocuments(into) {
  if (!into) return;

  const docs = await knowledgeBase.getAllDocuments();
  if (docs.length === 0) {
    into.innerHTML = '<p style="color:#ccc">No documents yet.</p>';
    return;
  }

  let html = '';
  for (let i = 0; i < docs.length; i++) {
    const d = docs[i];
    const idx = i + 1;
    const size = (d.size / (1024 * 1024)).toFixed(2);
    const ocr = d.conversionType === 'OCR Enhanced' || d.conversionType === 'OCR Processing'
      ? '<span class="badge" style="border-color:var(--violet);color:var(--violet)">OCR</span>'
      : '';
    
    const hasSearchable = d.searchableContent && d.searchableContent.length > 0;
    const searchableStatus = hasSearchable 
      ? `<span class="badge" style="border-color:var(--neon);color:var(--neon)">Searchable</span>`
      : '<span class="badge" style="border-color:var(--warn);color:var(--warn)">Limited</span>';

    const pageInfo = d.pageCount ? `<span class="badge" style="border-color:#00bfff;color:#00bfff">${d.pageCount} pages</span>` : '';

    html += `
    <div style="display:flex;justify-content:space-between;align-items:center;border:1px solid rgba(0,255,136,.35);border-radius:8px;padding:10px;margin:8px 0;background:rgba(0,0,0,.25)">
      <div>
        <strong>${idx}.</strong> üìÑ ${d.filename} ${ocr} ${searchableStatus} ${pageInfo}
        <div style="color:#aaa;font-size:.85rem">${d.fileType}, ${size}MB, ${d.wordCount} words, ${d.conversionType}</div>
      </div>
      <button class="btn btn-danger" onclick="deleteDocument('${d.id}')">üóëÔ∏è Delete</button>
    </div>`;
  }

  into.innerHTML = html;
}

async function updateDocumentsList() {
  await knowledgeBase.ready;
  await renderDocuments(byId('documentsList'));
}

async function deleteDocument(id) {
  await knowledgeBase.deleteDocument(id);
  await updateDocumentsList();
  toast('Document deleted', 'warn');
}

// ===== Enhanced Highlight Function with Navigation =====
function highlightTextWithNavigation(text, query, contextSize = 100) {
  if (!query || !text) return { html: text, matches: [] };

  const queryLower = query.toLowerCase();
  const textLower = text.toLowerCase();
  const terms = queryLower.split(/\s+/).filter(t => t.length > 0);
  
  let html = '';
  const matches = [];
  let lastIndex = 0;

  // Find all exact matches for each term
  for (const term of terms) {
    const termRegex = new RegExp(`\\b${term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'gi');
    let match;
    
    while ((match = termRegex.exec(text)) !== null) {
      matches.push({
        term: term,
        index: match.index,
        length: match[0].length
      });
    }
  }

  // Sort matches by position
  matches.sort((a, b) => a.index - b.index);

  // Create HTML with highlights
  if (matches.length === 0) {
    return { html: text, matches: [] };
  }

  // Create highlighted segments with context
  for (let i = 0; i < matches.length; i++) {
    const match = matches[i];
    const start = Math.max(0, match.index - contextSize);
    const end = Math.min(text.length, match.index + match.length + contextSize);
    
    let segment = text.substring(start, end);
    
    // Highlight the term
    const termRegex = new RegExp(`\\b${match.term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'gi');
    segment = segment.replace(termRegex, `<span class="highlight-match">$&</span>`);
    
    // Add ellipsis if not at beginning
    if (start > 0) segment = '...' + segment;
    if (end < text.length) segment = segment + '...';
    
    html += `<div style="margin-bottom:8px;padding:4px;border-left:3px solid var(--neon);background:rgba(0,255,136,.05);">${segment}</div>`;
  }

  return { html, matches };
}

// ===== Search Navigation Functions =====
function updateSearchNavigation() {
  const nav = byId('searchNavigation');
  const prevBtn = byId('prevMatchBtn');
  const nextBtn = byId('nextMatchBtn');
  const matchInfo = byId('matchInfo');
  
  if (currentSearchState.totalMatches === 0) {
    hide(nav);
    return;
  }
  
  show(nav);
  prevBtn.disabled = currentSearchState.currentMatchIndex === 0;
  nextBtn.disabled = currentSearchState.currentMatchIndex >= currentSearchState.totalMatches - 1;
  
  const docName = currentSearchState.results[currentSearchState.currentDocumentIndex]?.filename || 'Document';
  const pageNum = currentSearchState.results[currentSearchState.currentDocumentIndex]?.pages?.[currentSearchState.currentPageIndex]?.pageNumber || 1;
  
  matchInfo.innerHTML = `
    Match <strong>${currentSearchState.currentMatchIndex + 1}</strong> of <strong>${currentSearchState.totalMatches}</strong>
    <span class="page-indicator" style="margin-left:8px">${docName} - Page ${pageNum}</span>
  `;
}

function navigateToMatch(direction) {
  if (currentSearchState.totalMatches === 0) return;
  
  if (direction === 'next') {
    if (currentSearchState.currentMatchIndex < currentSearchState.totalMatches - 1) {
      currentSearchState.currentMatchIndex++;
    }
  } else if (direction === 'prev') {
    if (currentSearchState.currentMatchIndex > 0) {
      currentSearchState.currentMatchIndex--;
    }
  }
  
  // Update display
  displayCurrentMatch();
  updateSearchNavigation();
}

function displayCurrentMatch() {
  const resultsArea = byId('resultsArea');
  const results = currentSearchState.results;
  
  if (results.length === 0 || currentSearchState.totalMatches === 0) {
    resultsArea.innerHTML = '<div class="card">No matches found.</div>';
    return;
  }
  
  // For now, just show the current match index in navigation
  // In a more advanced version, you could scroll to the specific match
  updateSearchNavigation();
}

// ===== Enhanced Local Content Search with Navigation =====
async function performLocalContentSearch() {
  const q = byId('searchInput').value.trim();
  if(!q) return toast('Enter a search query','warn');
  
  setSearchVisible(); 
  byId('statusText').textContent = 'BATHALA INTELLIGENCE: Searching local content (exact match)‚Ä¶';
  
  // Reset search state
  currentSearchState = {
    query: q,
    results: [],
    currentDocumentIndex: 0,
    currentPageIndex: 0,
    currentMatchIndex: 0,
    totalMatches: 0
  };
  
  const docs = await knowledgeBase.searchDocumentsExact(q);
  
  if(docs.length === 0) {
    byId('resultsArea').innerHTML = `<div class='card'>
      <h3>‚ùå No content matches for "${q}"</h3>
      <p>Try searching for different terms or check if files have been properly processed.</p>
    </div>`;
    hide(byId('searchNavigation'));
  } else {
    let html = `<h3 style="color:var(--neon);margin-bottom:12px">üîç Found ${docs.length} document(s) containing "${q}"</h3>`;
    let totalMatches = 0;
    const enhancedResults = [];
    
    for (const doc of docs) {
      // Get pages for this document
      const pages = await knowledgeBase.getDocumentPages(doc.id);
      let docTotalMatches = 0;
      const matchingPages = [];
      
      // Search in each page
      for (const page of pages) {
        const highlighted = highlightTextWithNavigation(page.content, q, 150);
        if (highlighted.matches.length > 0) {
          docTotalMatches += highlighted.matches.length;
          matchingPages.push({
            page,
            highlighted,
            matchCount: highlighted.matches.length
          });
        }
      }
      
      totalMatches += docTotalMatches;
      
      enhancedResults.push({
        ...doc,
        pages: matchingPages,
        totalMatches: docTotalMatches
      });
      
      // Display document summary
      const ocrBadge = doc.conversionType === 'OCR Enhanced' || doc.conversionType === 'OCR Processing'
        ? '<span class="badge" style="border-color:var(--violet);color:var(--violet);margin-left:8px">OCR</span>'
        : '';
      
      const pageCount = pages.length;
      const matchingPageCount = matchingPages.length;
      
      html += `<div class='response-card' style="margin-bottom:16px;">
        <div class='response-header'>
          <div class='provider-badge'>üìñ ${doc.filename} ${ocrBadge}</div>
          <div>${(doc.size/(1024*1024)).toFixed(2)}MB ‚Ä¢ ${doc.conversionType}</div>
        </div>
        <div class='response-content'>
          <div style="margin-bottom:10px;padding:8px;background:rgba(0,255,136,.08);border-radius:6px">
            <strong>Found ${docTotalMatches} matches</strong> across ${matchingPageCount} of ${pageCount} pages
          </div>`;
      
      // Show first few matching pages
      for (let i = 0; i < Math.min(3, matchingPages.length); i++) {
        const mp = matchingPages[i];
        html += `
          <div style="margin-top:12px;padding:10px;border:1px solid rgba(0,255,136,.2);border-radius:8px;background:rgba(0,0,0,.2)">
            <div style="display:flex;justify-content:space-between;margin-bottom:6px">
              <strong>Page ${mp.page.pageNumber}</strong>
              <span class="badge" style="background:rgba(255,255,0,.2);border-color:yellow">${mp.matchCount} match(es)</span>
            </div>
            ${mp.highlighted.html}
          </div>`;
      }
      
      if (matchingPages.length > 3) {
        html += `<div style="margin-top:8px;text-align:center;color:var(--muted)">
          ... and ${matchingPages.length - 3} more pages with matches
        </div>`;
      }
      
      html += `
          <div style="margin-top:12px;padding:8px;background:rgba(0,0,0,.3);border-radius:6px;font-size:0.85rem">
            <strong>Document Info:</strong> ${doc.fileType}, ${pages.length} pages, uploaded ${new Date(doc.uploadDate).toLocaleDateString()}
          </div>
        </div>
      </div>`;
    }
    
    // Update search state
    currentSearchState.results = enhancedResults;
    currentSearchState.totalMatches = totalMatches;
    
    byId('resultsArea').innerHTML = html;
    
    // Setup navigation if we have matches
    if (totalMatches > 0) {
      updateSearchNavigation();
      
      // Bind navigation buttons
      byId('prevMatchBtn').onclick = () => navigateToMatch('prev');
      byId('nextMatchBtn').onclick = () => navigateToMatch('next');
      
      // Add keyboard navigation
      document.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowLeft') navigateToMatch('prev');
        if (e.key === 'ArrowRight') navigateToMatch('next');
      });
    } else {
      hide(byId('searchNavigation'));
    }
    
    console.log('Content search results:', {
      query: q,
      found: docs.length,
      totalMatches: totalMatches,
      documents: enhancedResults.map(d => ({
        name: d.filename,
        matches: d.totalMatches,
        pages: d.pages?.length || 0
      }))
    });
    
    await knowledgeBase.pushHistory({ 
      type: 'search', 
      title: `Content: ${q.slice(0,48)} (${totalMatches} matches)`, 
      payload: html 
    }); 
    await refreshHistory();
  }
}

// All other existing functions remain...
async function performLocalFileSearch(){
  const q=byId('searchInput').value.trim(); if(!q) return toast('Enter a search query','warn');
  setSearchVisible(); byId('statusText').textContent='BATHALA INTELLIGENCE: Searching local file database‚Ä¶';
  const docs=await knowledgeBase.searchDocumentsExact(q);
  if(docs.length===0){
    byId('resultsArea').innerHTML = `<div class='card'>‚ùå No files match "${q}"</div>`;
  } else {
    let ctx='Found '+docs.length+" file(s):\n\n";
    docs.forEach((d,i)=>{ 
      const ocrNote = d.conversionType === 'OCR Enhanced' ? ' (OCR Processed)' : '';
      const pageNote = d.pageCount ? ` (${d.pageCount} pages)` : '';
      ctx+=`üìÑ ${i+1}. ${d.filename}${ocrNote}${pageNote} (${(d.size/(1024*1024)).toFixed(2)}MB)\n`; 
    });
    const body = `<div class='response-card'><div class='response-header'><div class='provider-badge'>üìÅ File Database</div><div>File Search</div></div><div class='response-content'>${highlight(ctx,q)}</div></div>`;
    byId('resultsArea').innerHTML = body;
    await knowledgeBase.pushHistory({ type:'search', title:`Files: ${q.slice(0,48)}`, payload: body }); await refreshHistory();
  }
}

async function performAISearch() {
  const query=byId('searchInput').value.trim();
  const provider=byId('aiProvider').value;
  const persona=byId('personaSelect').value;
  if(!query) return toast('Enter a search query','warn');
  const hasKeys=['deepseek','openai','grok'].some(p=> byId(p+'Key')?.value);
  if(!hasKeys) return toast('Configure at least one AI key','warn');
  setSearchVisible(); byId('resultsArea').innerHTML='';
  byId('statusText').textContent='BATHALA INTELLIGENCE: Executing AI search‚Ä¶';
  if(provider==='compare'){
    const out=[];
    for(const prov of ['deepseek','openai','grok']){
      const key=byId(prov+'Key')?.value;
      if(!key){ out.push({provider:prov, success:false, error:'API key not configured', responseTime:0}); continue;}
      const r=await queryAI(prov, query, key, persona); out.push({provider:prov, ...r});
    }
    const html = renderCompareResults(query, out);
    byId('resultsArea').innerHTML = html;
    byId('checkBalanceBtn').style.display='';
    byId('forecastBtn').style.display='';
    await knowledgeBase.pushHistory({ type:'search', title: query.slice(0,60), payload: html }); await refreshHistory();
  } else {
    const key=byId(provider+'Key')?.value; if(!key) { return toast(`Configure ${API_CONFIG[provider].name} key`,'warn'); }
    const r=await queryAI(provider, query, key, persona);
    const body = r.success? r.content : `<div style='color:var(--error)'>‚ùå ${r.error}</div>`;
    const html = `<div class="response-card">
      <div class="response-header"><div class="provider-badge">${API_CONFIG[provider].name}</div><div class="response-time">${r.responseTime}ms${r.cached?' ¬∑ cached':''}</div></div>
      <div class="response-content">${body}</div>
    </div>`;
    byId('resultsArea').innerHTML = html;
    byId('checkBalanceBtn').style.display='';
    byId('forecastBtn').style.display='';
    await knowledgeBase.pushHistory({ type:'search', title: `${API_CONFIG[provider].name}: ${query.slice(0,48)}`, payload: html }); await refreshHistory();
  }
  byId('statusText').textContent='BATHALA INTELLIGENCE: AI search completed';
}

async function performCombinedSearch(){
  const q=byId('searchInput').value.trim();
  const provider=byId('aiProvider').value;
  const persona=byId('personaSelect').value;
  if(!q) return toast('Enter a search query','warn');
  const hasKeys=['deepseek','openai','grok'].some(p=> byId(p+'Key')?.value);
  if(!hasKeys) return toast('Configure at least one AI key','warn');
  setSearchVisible(); byId('statusText').textContent='BATHALA INTELLIGENCE: Executing combined AI search‚Ä¶';

  if(provider==='compare'){
    const out=[];
    for(const prov of ['deepseek','openai','grok']){
      const key=byId(prov+'Key')?.value;
      if(!key){ out.push({provider:prov, success:false, error:'API key not configured', responseTime:0}); continue;}
      const r=await combinedAIQuery(prov, q, key, persona); out.push({provider:prov, ...r});
    }
    const html = renderCompareResults(q, out);
    byId('resultsArea').innerHTML = html;
    
    const hasActualResults = out.some(r => r.success && !r.noMatch);
    byId('checkBalanceBtn').style.display = hasActualResults ? '' : 'none';
    byId('forecastBtn').style.display = hasActualResults ? '' : 'none';
    
    await knowledgeBase.pushHistory({ type:'search', title:`Combined: ${q.slice(0,48)}`, payload: html }); 
    await refreshHistory();
  } else {
    const key=byId(provider+'Key')?.value; if(!key){ return toast(`Configure ${API_CONFIG[provider].name} key`,'warn'); }
    const r=await combinedAIQuery(provider, q, key, persona);
    const body = r.success? r.content : `<div style='color:var(--error)'>‚ùå ${r.error}</div>`;
    const noMatchStyle = r.noMatch ? 'style="border-color: var(--warn); background: rgba(255,165,0,.05);"' : '';
    const html = `<div class="response-card" ${noMatchStyle}>
      <div class="response-header">
        <div class="provider-badge">${API_CONFIG[provider].name}</div>
        <div class="response-time">${r.responseTime}ms${r.cached?' ¬∑ cached':''}</div>
      </div>
      <div class="response-content">${body}</div>
      ${!r.noMatch ? `
      <div style="margin-top:12px;padding:10px;background:rgba(255,165,0,.08);border:1px solid var(--warn);border-radius:8px">
        <strong>Search Type:</strong> Combined (Local DB + AI) ‚Ä¢ <strong>Mode:</strong> ${persona}
      </div>
      ` : ''}
    </div>`;
    byId('resultsArea').innerHTML = html;
    byId('checkBalanceBtn').style.display = r.noMatch ? 'none' : '';
    byId('forecastBtn').style.display = r.noMatch ? 'none' : '';
    await knowledgeBase.pushHistory({ type:'search', title:`${API_CONFIG[provider].name}: ${q.slice(0,48)}`, payload: html }); 
    await refreshHistory();
  }
  byId('statusText').textContent='BATHALA INTELLIGENCE: Combined search completed';
}

async function performAgentsSearch() {
  const q = byId('searchInput').value.trim();
  const provider = byId('aiProvider').value;
  const persona = byId('personaSelect').value;
  
  if (!q) return toast('Enter a search query', 'warn');
  
  const hasKeys = ['deepseek', 'openai', 'grok'].some(p => byId(p + 'Key')?.value);
  if (!hasKeys) return toast('Configure at least one AI key', 'warn');
  
  setSearchVisible(); 
  byId('statusText').textContent = 'BATHALA INTELLIGENCE: Querying connected databases‚Ä¶';

  if (provider === 'compare') {
    const out = [];
    for (const prov of ['deepseek', 'openai', 'grok']) {
      const key = byId(prov + 'Key')?.value;
      if (!key) { 
        out.push({ provider: prov, success: false, error: 'API key not configured', responseTime: 0 }); 
        continue;
      }
      const r = await databaseAIQuery(prov, q, key, persona); 
      out.push({ provider: prov, ...r });
    }
    const html = renderCompareResults(q, out);
    byId('resultsArea').innerHTML = html;
    
    const hasActualResults = out.some(r => r.success && !r.noMatch);
    byId('checkBalanceBtn').style.display = hasActualResults ? '' : 'none';
    byId('forecastBtn').style.display = hasActualResults ? '' : 'none';
    
    await knowledgeBase.pushHistory({ type: 'search', title: `Agents: ${q.slice(0, 48)}`, payload: html }); 
    await refreshHistory();
  } else {
    const key = byId(provider + 'Key')?.value; 
    if (!key) { 
      return toast(`Configure ${API_CONFIG[provider].name} key`, 'warn'); 
    }
    const r = await databaseAIQuery(provider, q, key, persona);
    const body = r.success ? r.content : `<div style='color:var(--error)'>‚ùå ${r.error}</div>`;
    const noMatchStyle = r.noMatch ? 'style="border-color: var(--warn); background: rgba(255,165,0,.05);"' : '';
    const html = `<div class="response-card" ${noMatchStyle}>
      <div class="response-header">
        <div class="provider-badge">${API_CONFIG[provider].name}</div>
        <div class="response-time">${r.responseTime}ms${r.cached ? ' ¬∑ cached' : ''}</div>
      </div>
      <div class="response-content">${body}</div>
      ${!r.noMatch ? `
      <div style="margin-top:12px;padding:10px;background:rgba(255,165,0,.08);border:1px solid var(--warn);border-radius:8px">
        <strong>Search Type:</strong> Database Agents ‚Ä¢ <strong>Mode:</strong> ${persona} ‚Ä¢ <strong>Source:</strong> Connected Databases
      </div>
      ` : ''}
    </div>`;
    byId('resultsArea').innerHTML = html;
    byId('checkBalanceBtn').style.display = r.noMatch ? 'none' : '';
    byId('forecastBtn').style.display = r.noMatch ? 'none' : '';
    await knowledgeBase.pushHistory({ type: 'search', title: `${API_CONFIG[provider].name} Agents: ${q.slice(0, 48)}`, payload: html }); 
    await refreshHistory();
  }
  byId('statusText').textContent = 'BATHALA INTELLIGENCE: Database query completed';
}

async function performSuperModeSearch() {
  const q = byId('searchInput').value.trim();
  const provider = byId('aiProvider').value;
  const persona = byId('personaSelect').value;
  
  if (!q) return toast('Enter a search query', 'warn');
  
  const hasKeys = ['deepseek', 'openai', 'grok'].some(p => byId(p + 'Key')?.value);
  if (!hasKeys) return toast('Configure at least one AI key', 'warn');
  
  setSearchVisible(); 
  byId('statusText').textContent = 'BATHALA INTELLIGENCE: Activating SUPER MODE (Library + Database + AI Engines)‚Ä¶';

  if (provider === 'compare') {
    const out = [];
    for (const prov of ['deepseek', 'openai', 'grok']) {
      const key = byId(prov + 'Key')?.value;
      if (!key) { 
        out.push({ provider: prov, success: false, error: 'API key not configured', responseTime: 0 }); 
        continue;
      }
      const r = await superModeAIQuery(prov, q, key, persona); 
      out.push({ provider: prov, ...r });
    }
    const html = renderCompareResults(q, out);
    byId('resultsArea').innerHTML = html;
    
    const hasActualResults = out.some(r => r.success && !r.noMatch);
    byId('checkBalanceBtn').style.display = hasActualResults ? '' : 'none';
    byId('forecastBtn').style.display = hasActualResults ? '' : 'none';
    
    await knowledgeBase.pushHistory({ type: 'search', title: `SUPER MODE: ${q.slice(0, 48)}`, payload: html }); 
    await refreshHistory();
  } else {
    const key = byId(provider + 'Key')?.value; 
    if (!key) { 
      return toast(`Configure ${API_CONFIG[provider].name} key`, 'warn'); 
    }
    const r = await superModeAIQuery(provider, q, key, persona);
    const body = r.success ? r.content : `<div style='color:var(--error)'>‚ùå ${r.error}</div>`;
    const noMatchStyle = r.noMatch ? 'style="border-color: var(--warn); background: rgba(255,165,0,.05);"' : '';
    const html = `<div class="response-card" ${noMatchStyle}>
      <div class="response-header">
        <div class="provider-badge">${API_CONFIG[provider].name}</div>
        <div class="response-time">${r.responseTime}ms${r.cached ? ' ¬∑ cached' : ''}</div>
      </div>
      <div class="response-content">${body}</div>
      ${!r.noMatch ? `
      <div style="margin-top:12px;padding:10px;background:rgba(255,0,255,.08);border:1px solid #ff00ff;border-radius:8px">
        <strong>Search Type:</strong> SUPER MODE ‚Ä¢ <strong>Mode:</strong> ${persona} ‚Ä¢ <strong>Sources:</strong> Library + Databases + AI Engines
      </div>
      ` : ''}
    </div>`;
    byId('resultsArea').innerHTML = html;
    byId('checkBalanceBtn').style.display = r.noMatch ? 'none' : '';
    byId('forecastBtn').style.display = r.noMatch ? 'none' : '';
    await knowledgeBase.pushHistory({ type: 'search', title: `SUPER MODE ${API_CONFIG[provider].name}: ${q.slice(0, 48)}`, payload: html }); 
    await refreshHistory();
  }
  byId('statusText').textContent = 'BATHALA INTELLIGENCE: SUPER MODE analysis completed';
}

async function performForecastAnalysis() {
  const q = byId('searchInput').value.trim();
  const provider = byId('aiProvider').value;
  const persona = byId('personaSelect').value;
  
  if (!q) return toast('Enter a search query', 'warn');
  
  const hasKeys = ['deepseek', 'openai', 'grok'].some(p => byId(p + 'Key')?.value);
  if (!hasKeys) return toast('Configure at least one AI key', 'warn');
  
  setSearchVisible(); 
  byId('statusText').textContent = 'BATHALA INTELLIGENCE: Generating 1-5 year forecast‚Ä¶';

  if (provider === 'compare') {
    const out = [];
    for (const prov of ['deepseek', 'openai', 'grok']) {
      const key = byId(prov + 'Key')?.value;
      if (!key) { 
        out.push({ provider: prov, success: false, error: 'API key not configured', responseTime: 0 }); 
        continue;
      }
      const r = await forecastAIQuery(prov, q, key, persona); 
      out.push({ provider: prov, ...r });
    }
    const html = renderCompareResults(`Forecast: ${q}`, out);
    byId('resultsArea').innerHTML = html;
    
    await knowledgeBase.pushHistory({ type: 'search', title: `FORECAST: ${q.slice(0, 48)}`, payload: html }); 
    await refreshHistory();
  } else {
    const key = byId(provider + 'Key')?.value; 
    if (!key) { 
      return toast(`Configure ${API_CONFIG[provider].name} key`, 'warn'); 
    }
    const r = await forecastAIQuery(provider, q, key, persona);
    const body = r.success ? r.content : `<div style='color:var(--error)'>‚ùå ${r.error}</div>`;
    const noMatchStyle = r.noMatch ? 'style="border-color: var(--warn); background: rgba(255,165,0,.05);"' : '';
    const html = `<div class="response-card" ${noMatchStyle}>
      <div class="response-header">
        <div class="provider-badge">${API_CONFIG[provider].name}</div>
        <div class="response-time">${r.responseTime}ms${r.cached ? ' ¬∑ cached' : ''}</div>
      </div>
      <div class="response-content">${body}</div>
      ${!r.noMatch ? `
      <div style="margin-top:12px;padding:10px;background:rgba(0,191,255,.08);border:1px solid #00bfff;border-radius:8px">
        <strong>Analysis Type:</strong> FORECAST ‚Ä¢ <strong>Timeframe:</strong> 1-5 Years ‚Ä¢ <strong>Mode:</strong> ${persona}
      </div>
      ` : ''}
    </div>`;
    byId('resultsArea').innerHTML = html;
    await knowledgeBase.pushHistory({ type: 'search', title: `FORECAST ${API_CONFIG[provider].name}: ${q.slice(0, 48)}`, payload: html }); 
    await refreshHistory();
  }
  byId('statusText').textContent = 'BATHALA INTELLIGENCE: Forecast analysis completed';
}

// ===== Combined AI Query =====
async function combinedAIQuery(provider, query, apiKey, persona) {
  const relevantDocs = await knowledgeBase.searchDocumentsExact(query);

  if (relevantDocs.length === 0) {
    return {
      success: true,
      content: `‚ùå No matching documents found for: "${query}".\n\nSearch query does not match any content in the local library. Analysis will not proceed to conserve API resources.`,
      responseTime: 0,
      noMatch: true
    };
  }

  let all = '';
  relevantDocs.forEach((d, i) => {
    const contentToUse = d.searchableContent || d.content || '';
    all += `DOCUMENT ${i + 1}: ${d.filename} (${d.conversionType})\n${contentToUse.slice(0, 12000)}\n\n`;
  });

  const enhanced = `${PERSONA[persona || 'strategist']}
Use ONLY the provided document text unless specified.
USER QUERY: ${query}

DOCUMENT DATA:
${all}`;

  return await queryAI(provider, enhanced, apiKey, persona);
}

// ===== Database AI Query =====
async function databaseAIQuery(provider, query, apiKey, persona) {
  const connectedDbs = dbManager.getConnectedDatabases();
  
  if (connectedDbs.length === 0) {
    return {
      success: true,
      content: `‚ùå No connected databases found. 

Available Connection Options:
1. **SQLite Files**: Upload .db files directly (perfect for NAS storage)
2. **Excel Files**: Upload .xlsx/.xls files directly
3. **CSV Files**: Upload .csv files directly
4. **Server Databases**: PostgreSQL, MySQL, Oracle, SQL Server (requires backend)
5. **Quick Start**: Export server databases to SQLite format

For document search: Use "Bathala Mode" to search your document library instead.`,
      responseTime: 0,
      noMatch: true
    };
  }

  let databaseInfo = 'CONNECTED DATABASES:\n\n';
  
  connectedDbs.forEach((db, i) => {
    const template = DATABASE_TEMPLATES[db.dbType];
    databaseInfo += `DATABASE ${i + 1}: ${db.name} (${template.name})\n`;
    databaseInfo += `Type: ${template.connectionType === 'direct' ? 'File Database' : 'Server Database'}\n`;
    
    if (db.tables && db.tables.length > 0) {
      databaseInfo += `Tables: ${db.tables.slice(0, 5).map(t => t.name).join(', ')}`;
      if (db.tables.length > 5) databaseInfo += `... and ${db.tables.length - 5} more`;
      databaseInfo += '\n';
    }
    
    if (db.databaseInfo) {
      databaseInfo += `Info: ${db.databaseInfo.tablesCount || db.databaseInfo.sheetsCount || 0} ${db.dbType === 'excel' ? 'sheets' : 'tables'}, ${db.databaseInfo.totalRows || 0} rows\n`;
    }
    databaseInfo += '\n';
  });

  const enhanced = `${PERSONA[persona || 'strategist']}

USER QUERY: ${query}

${databaseInfo}

ANALYSIS REQUEST:
Analyze the available database structure and provide insights based on the user's query. 

For file databases (SQLite, Excel, CSV): Suggest what data might be relevant and potential queries.
For server databases: Suggest data relationships and analysis opportunities.

Focus on the database structure and how it relates to the user's query.`;

  return await queryAI(provider, enhanced, apiKey, persona);
}

// ===== Super Mode AI Query =====
async function superModeAIQuery(provider, query, apiKey, persona) {
  const relevantDocs = await knowledgeBase.searchDocumentsExact(query);
  const connectedDbs = dbManager.getConnectedDatabases();
  
  let context = 'SUPER MODE ANALYSIS - INTEGRATED DATA SOURCES:\n\n';

  if (relevantDocs.length > 0) {
    context += 'üìö LIBRARY DOCUMENTS:\n';
    relevantDocs.forEach((d, i) => {
      const contentToUse = d.searchableContent || d.content || '';
      context += `DOCUMENT ${i + 1}: ${d.filename} (${d.conversionType})\n${contentToUse.slice(0, 8000)}\n\n`;
    });
  } else {
    context += 'üìö LIBRARY: No matching documents found\n\n';
  }

  if (connectedDbs.length > 0) {
    context += 'üóÉÔ∏è CONNECTED DATABASES:\n';
    connectedDbs.forEach((db, i) => {
      const template = DATABASE_TEMPLATES[db.dbType];
      context += `DATABASE ${i + 1}: ${db.name} (${template.name})\n`;
      context += `Type: ${template.connectionType === 'direct' ? 'File Database' : 'Server Database'}\n`;
      
      if (db.tables && db.tables.length > 0) {
        context += `Tables: ${db.tables.slice(0, 3).map(t => t.name).join(', ')}`;
        if (db.tables.length > 3) context += `... and ${db.tables.length - 3} more`;
        context += '\n';
      }
      
      if (db.databaseInfo) {
        context += `Info: ${db.databaseInfo.tablesCount || db.databaseInfo.sheetsCount || 0} ${db.dbType === 'excel' ? 'sheets' : 'tables'}, ${db.databaseInfo.totalRows || 0} rows\n`;
      }
      context += '\n';
    });
  } else {
    context += 'üóÉÔ∏è DATABASES: No connected databases\n\n';
  }

  context += 'üß† AI ANALYSIS ENGINES:\n';
  context += '‚Ä¢ Multiple AI models for cross-verification\n';
  context += '‚Ä¢ Real-time data processing\n';
  context += '‚Ä¢ Advanced pattern recognition\n\n';

  const enhanced = `${PERSONA[persona || 'strategist']}

USER QUERY: ${query}

${context}

SUPER MODE ANALYSIS REQUEST:
Perform comprehensive analysis using ALL available data sources. Integrate insights from documents, databases, and AI engines. Provide the most complete and accurate response possible, highlighting connections between different data sources and identifying patterns that wouldn't be visible from individual sources alone.`;

  return await queryAI(provider, enhanced, apiKey, persona);
}

// ===== Forecast AI Query =====
async function forecastAIQuery(provider, query, apiKey, persona) {
  const resultsCards = $$('.response-card');
  if (resultsCards.length === 0) {
    return {
      success: true,
      content: `‚ùå No search results available for forecasting.\n\nPlease perform a search first to generate data for forecasting analysis.`,
      responseTime: 0,
      noMatch: true
    };
  }

  let allResults = 'SEARCH RESULTS FOR FORECASTING ANALYSIS:\n\n';
  
  resultsCards.forEach((card, i) => {
    const providerName = card.querySelector('.provider-badge')?.textContent || `Result ${i + 1}`;
    const content = card.querySelector('.response-content')?.textContent || '';
    
    allResults += `RESULT ${i + 1} (${providerName}):\n${content.slice(0, 5000)}\n\n---\n\n`;
  });

  const enhanced = `${PERSONA[persona || 'strategist']}

FORECASTING ANALYSIS REQUEST:

USER QUERY: ${query}

AVAILABLE DATA:
${allResults}

FORECASTING INSTRUCTIONS:
Based on the search results above, provide a comprehensive 1-5 year forecast. Include:

1. **SHORT-TERM (1-2 years):** Immediate trends, opportunities, and risks
2. **MID-TERM (3-4 years):** Evolving patterns and strategic implications  
3. **LONG-TERM (5+ years):** Transformative changes and paradigm shifts

Structure your response with:
- Key drivers and influencing factors
- Probability assessments for different scenarios
- Recommended actions and contingency plans
- Metrics for tracking progress and validation

Focus on actionable insights and evidence-based projections.`;

  return await queryAI(provider, enhanced, apiKey, persona);
}

// ===== Helper Functions =====
function setSearchVisible() {
  const sec = byId('resultsSection');
  if(sec) sec.style.display='';
}

function highlight(text, q) {
  if (!q || !text) return text;

  const terms = q.split(/\s+/).filter(t => t.length > 2);
  let t = text;

  for (const term of terms) {
    const re = new RegExp(`(${term.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')})`, 'gi');
    t = t.replace(re, '<span style="background:yellow;color:#000;border-radius:3px;padding:0 3px">$1</span>');
  }

  return t;
}

function renderCompareResults(query, results) {
  let html = `<h3 style="color:var(--warn);margin-bottom:12px">üöÄ AI SEARCH: "${query}"</h3><div class="response-grid">`;
  for(const r of results){
    const body = r.success? r.content : `<div style='color:var(--error)'>‚ùå ${r.error}</div>`;
    const noMatchStyle = r.noMatch ? 'style="border-color: var(--warn); background: rgba(255,165,0,.05);"' : '';
    html += `<div class="response-card" ${noMatchStyle}>
      <div class="response-header"><div class="provider-badge">${API_CONFIG[r.provider].name}</div><div class="response-time">${r.responseTime}ms${r.cached?' ¬∑ cached':''}</div></div>
      <div class="response-content">${body}</div>
    </div>`;
  }
  html+='</div>';
  return html;
}

function getArbitrationProvider() {
  for (const p of ['openai', 'deepseek', 'grok']) {
    const el = byId(`${p}Key`);
    if (el && el.value) return p;
  }
  return null;
}

// ===== Database Manager (truncated for brevity) =====
// ... [Database Manager code remains the same as before] ...

const dbManager = new (class HybridDatabaseManager {
  constructor() {
    this.connections = JSON.parse(localStorage.getItem('bathala_hybrid_databases') || '[]');
    this.nextId = Math.max(0, ...this.connections.map(c => c.id)) + 1;
  }

  saveConnections() { localStorage.setItem('bathala_hybrid_databases', JSON.stringify(this.connections)); }
  async addConnection(connectionData, file = null) {
    const template = DATABASE_TEMPLATES[connectionData.dbType];
    const newConnection = { id: this.nextId++, ...connectionData, connectionType: template.connectionType, status: 'disconnected' };
    this.connections.push(newConnection); this.saveConnections(); return newConnection;
  }
  updateConnection(id, updates) { const c = this.connections.find(c => c.id === id); if(c){ Object.assign(c, updates); this.saveConnections(); } }
  removeConnection(id) { this.connections = this.connections.filter(c => c.id !== id); this.saveConnections(); }
  getConnections() { return this.connections; }
  getConnection(id) { return this.connections.find(c => c.id === id); }
  getConnectedDatabases() { return this.connections.filter(c => c.status === 'connected'); }
})();

// ===== Events =====
function bindEvents(){
  const fileInput = byId('fileInput');
  if(fileInput){
    fileInput.addEventListener('change', async (e)=>{
      const files=e.target.files;
      if(files.length>0){
        byId('statusText').textContent=`Processing ${files.length} file(s)‚Ä¶`;
        await fileProcessor.processFiles(files);
        byId('statusText').textContent=`${files.length} file(s) processed`;
        e.target.value='';
      }
    });
  }

  // Search events
  byId('searchBtn')?.addEventListener('click', performAISearch);
  byId('localFileBtn')?.addEventListener('click', performLocalFileSearch);
  byId('localContentBtn')?.addEventListener('click', performLocalContentSearch);
  byId('combinedBtn')?.addEventListener('click', performCombinedSearch);
  byId('agentsBtn')?.addEventListener('click', performAgentsSearch);
  byId('superModeBtn')?.addEventListener('click', performSuperModeSearch);
  byId('checkBalanceBtn')?.addEventListener('click', checkBalance);
  byId('forecastBtn')?.addEventListener('click', performForecastAnalysis);

  // Agent events
  byId('connectAgentsBtn')?.addEventListener('click', async ()=>{
    byId('statusText').textContent='Connecting AI Agents‚Ä¶';
    const results = await Promise.all([
      testApiConnection('deepseek'), 
      testApiConnection('openai'), 
      testApiConnection('grok')
    ]);
    
    const connectedCount = results.filter(r => r === true).length;
    const savedCount = results.filter(r => r === false && 
      ['deepseek','openai','grok'].some(p => 
        byId(`${p}StatusText`).textContent.includes('Configured')
      )).length;
    
    const totalConfigured = connectedCount + savedCount;
    
    if(totalConfigured > 0){
      byId('globalStatus').className='status-dot connected';
      toast(`${connectedCount} connected, ${savedCount} configured`,'success');
      byId('statusText').textContent=`${totalConfigured}/3 AI Agents ready`;
    } else {
      toast('No agents connected or configured','warn');
      byId('statusText').textContent='No AI Agents ready';
    }
  });
  
  byId('disconnectAgentsBtn')?.addEventListener('click', ()=>{ 
    disconnectAgents(); 
    toast('Agents disconnected','warn'); 
  });
  
  byId('saveConfigBtn')?.addEventListener('click', ()=>{
    ['deepseek','openai','grok'].forEach(p=>{
      const k=byId(p+'Key')?.value;
      if(k){ 
        localStorage.setItem(p+'_api_key',k); 
        updateApiStatus(p,'saved'); 
      }
    });
    toast('Configuration saved','success');
  });
}

// ===== History renderers =====
async function refreshHistory(){
  const s=byId('searchHistory'); const c=byId('consensusHistory');
  if(!s||!c) return;
  const searches=await knowledgeBase.listHistory('search',8);
  const cons=await knowledgeBase.listHistory('consensus',8);
  s.innerHTML = searches.map(h=>`<button class='history-item' onclick='restoreHistory(${JSON.stringify(h.id)})'><span class='badge'>SEARCH</span><span>${h.title}</span></button>`).join('');
  c.innerHTML = cons.map(h=>`<button class='history-item' onclick='restoreHistory(${JSON.stringify(h.id)})'><span class='badge' style='border-color:var(--violet);color:var(--violet)'>CONSENSUS</span><span>${h.title}</span></button>`).join('');
}

async function restoreHistory(id){
  await knowledgeBase.ready;
  const tx=knowledgeBase.db.transaction(['history'],'readonly'); const st=tx.objectStore('history');
  const req=st.get(id);
  req.onsuccess=()=>{ const rec=req.result; if(rec){ setSearchVisible(); byId('resultsArea').innerHTML = rec.payload; } };
}

// ===== Init =====
(async function init(){
  await knowledgeBase.ready;
  loadApiKeys();
  await updateDocumentsList();
  await refreshHistory();
  bindEvents();
  
  console.log('Bathala v6.0 initialized with enhanced PDF processing and search navigation');
})();
</script>
</body>
</html>
